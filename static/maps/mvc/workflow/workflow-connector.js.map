{"version":3,"sources":["mvc/workflow/workflow-connector.js"],"names":["define","Connector","handle1","handle2","this","canvas","dragging","inner_color","outer_color","$","extend","prototype","connect","t1","t2","destroy","disconnect","attachable","destroyIfInvalid","redraw","canvas_container","createElement","append","relativeLeft","e","offset","left","relativeTop","top","start_x","element","start_y","canvas_min_x","Math","min","end_x","canvas_extra","max","canvas_max_x","canvas_min_y","end_y","canvas_max_y","cp_shift","canvas_left","canvas_top","canvas_height","style","getContext","start_offsets","c","end_offsets","isMappedOver","num_offsets","connector","i","outer_width","inner_width","length","draw_outlined_curve","offset_start","offset_end","lineCap","strokeStyle","lineWidth","beginPath","moveTo","bezierCurveTo","stroke"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-connector.js","sourcesContent":["define([], function() {\n    function Connector(handle1, handle2) {\n        this.canvas = null;\n        this.dragging = false;\n        this.inner_color = \"#FFFFFF\";\n        this.outer_color = \"#D8B365\";\n        if (handle1 && handle2) {\n            this.connect(handle1, handle2);\n        }\n    }\n    $.extend(Connector.prototype, {\n        connect: function(t1, t2) {\n            this.handle1 = t1;\n            if (this.handle1) {\n                this.handle1.connect(this);\n            }\n            this.handle2 = t2;\n            if (this.handle2) {\n                this.handle2.connect(this);\n            }\n        },\n        destroy: function() {\n            if (this.handle1) {\n                this.handle1.disconnect(this);\n            }\n            if (this.handle2) {\n                this.handle2.disconnect(this);\n            }\n            $(this.canvas).remove();\n        },\n        destroyIfInvalid: function() {\n            if (this.handle1 && this.handle2 && !this.handle2.attachable(this.handle1)) {\n                this.destroy();\n            }\n        },\n        redraw: function() {\n            var canvas_container = $(\"#canvas-container\");\n            if (!this.canvas) {\n                this.canvas = document.createElement(\"canvas\");\n                canvas_container.append($(this.canvas));\n                if (this.dragging) {\n                    this.canvas.style.zIndex = \"300\";\n                }\n            }\n            var relativeLeft = function(e) {\n                return $(e).offset().left - canvas_container.offset().left;\n            };\n            var relativeTop = function(e) {\n                return $(e).offset().top - canvas_container.offset().top;\n            };\n            if (!this.handle1 || !this.handle2) {\n                return;\n            }\n            // Find the position of each handle\n            var start_x = relativeLeft(this.handle1.element) + 5;\n            var start_y = relativeTop(this.handle1.element) + 5;\n            var end_x = relativeLeft(this.handle2.element) + 5;\n            var end_y = relativeTop(this.handle2.element) + 5;\n            // Calculate canvas area\n            var canvas_extra = 100;\n            var canvas_min_x = Math.min(start_x, end_x);\n            var canvas_max_x = Math.max(start_x, end_x);\n            var canvas_min_y = Math.min(start_y, end_y);\n            var canvas_max_y = Math.max(start_y, end_y);\n            var cp_shift = Math.min(Math.max(Math.abs(canvas_max_y - canvas_min_y) / 2, 100), 300);\n            var canvas_left = canvas_min_x - canvas_extra;\n            var canvas_top = canvas_min_y - canvas_extra;\n            var canvas_width = canvas_max_x - canvas_min_x + 2 * canvas_extra;\n            var canvas_height = canvas_max_y - canvas_min_y + 2 * canvas_extra;\n            // Place the canvas\n            this.canvas.style.left = canvas_left + \"px\";\n            this.canvas.style.top = canvas_top + \"px\";\n            this.canvas.setAttribute(\"width\", canvas_width);\n            this.canvas.setAttribute(\"height\", canvas_height);\n            // Adjust points to be relative to the canvas\n            start_x -= canvas_left;\n            start_y -= canvas_top;\n            end_x -= canvas_left;\n            end_y -= canvas_top;\n            // Draw the line\n\n            var c = this.canvas.getContext(\"2d\"),\n                start_offsets = null,\n                end_offsets = null;\n            var num_offsets = 1;\n            if (this.handle1 && this.handle1.isMappedOver()) {\n                var start_offsets = [-6, -3, 0, 3, 6];\n                num_offsets = 5;\n            } else {\n                var start_offsets = [0];\n            }\n            if (this.handle2 && this.handle2.isMappedOver()) {\n                var end_offsets = [-6, -3, 0, 3, 6];\n                num_offsets = 5;\n            } else {\n                var end_offsets = [0];\n            }\n            var connector = this;\n            for (var i = 0; i < num_offsets; i++) {\n                var inner_width = 5,\n                    outer_width = 7;\n                if (start_offsets.length > 1 || end_offsets.length > 1) {\n                    // We have a multi-run, using many lines, make them small.\n                    inner_width = 1;\n                    outer_width = 3;\n                }\n                connector.draw_outlined_curve(\n                    start_x,\n                    start_y,\n                    end_x,\n                    end_y,\n                    cp_shift,\n                    inner_width,\n                    outer_width,\n                    start_offsets[i % start_offsets.length],\n                    end_offsets[i % end_offsets.length]\n                );\n            }\n        },\n        draw_outlined_curve: function(\n            start_x,\n            start_y,\n            end_x,\n            end_y,\n            cp_shift,\n            inner_width,\n            outer_width,\n            offset_start,\n            offset_end\n        ) {\n            var offset_start = offset_start || 0;\n            var offset_end = offset_end || 0;\n            var c = this.canvas.getContext(\"2d\");\n            c.lineCap = \"round\";\n            c.strokeStyle = this.outer_color;\n            c.lineWidth = outer_width;\n            c.beginPath();\n            c.moveTo(start_x, start_y + offset_start);\n            c.bezierCurveTo(\n                start_x + cp_shift,\n                start_y + offset_start,\n                end_x - cp_shift,\n                end_y + offset_end,\n                end_x,\n                end_y + offset_end\n            );\n            c.stroke();\n            // Inner line\n            c.strokeStyle = this.inner_color;\n            c.lineWidth = inner_width;\n            c.beginPath();\n            c.moveTo(start_x, start_y + offset_start);\n            c.bezierCurveTo(\n                start_x + cp_shift,\n                start_y + offset_start,\n                end_x - cp_shift,\n                end_y + offset_end,\n                end_x,\n                end_y + offset_end\n            );\n            c.stroke();\n        }\n    });\n    return Connector;\n});\n"]}