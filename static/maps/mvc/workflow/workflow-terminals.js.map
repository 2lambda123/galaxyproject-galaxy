{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["define","Globals","CollectionTypeDescription","collectionType","this","length","NULL_COLLECTION_TYPE_DESCRIPTION","isCollection","canMapOver","other","toString","append","otherCollectionType","equal","ANY_COLLECTION_TYPE_DESCRIPTION","$","extend","prototype","otherCollectionTypeDescription","canMatch","rank","requiredSuffix","_endsWith","effectiveMapOver","substring","str","suffix","indexOf","TerminalMapping","Backbone","terminal","initialize","terminalMapping","mapOver","attr","disableMapOver","setMapOver","collectionTypeDescription","trigger","Terminal","connectors","Model","connect","element","markChanged","push","connector","node","disconnect","resetMappingIfNeeded","redraw","each","_","c","destroy","slice","destroyInvalidConnections","destroyIfInvalid","val","multiple","outputTerminal","output_terminals","resetMapping","OutputTerminal","datatypes","call","hasConnectedOutputTerminals","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","hasMappedOverInputTerminals","connectedInput","handle2","BaseInputTerminal","canAccept","update","_inputFilled","inputFilled","connected","inputsFilled","_collectionAttached","firstOutput","handle1","isMappedOver","_mappingConstraints","constraints","thisDatatype","first","t","connectedMappedInputTerminals","inputTerminal","_producesAcceptableDatatype","post_job_actions","cat_outputs","Array","concat","pja_i","other_datatype_i","other_datatype","pja","output_name","name","action_arguments","otherMapOver","app","isSubType","_otherCollectionType","input","other_output","InputTerminal","attachable","thisMapOver","every","bind","collection_types","InputCollectionTerminal","collection","extensions","collectionTypes","collectionTypeIndex","_effectiveMapOver","some","_effectiveCollectionTypes","effectiveCollectionTypes","map","effectiveCollectionType","OutputCollectionTerminal","collection_type","console","newCollectionType","collectionTypeSource","output","collection_type_source"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["define([\"mvc/workflow/workflow-globals\"], function(Globals) {\n    function CollectionTypeDescription(collectionType) {\n        this.collectionType = collectionType;\n        this.isCollection = true;\n        this.rank = collectionType.split(\":\").length;\n    }\n\n    var NULL_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: false,\n        canMatch: function(other) {\n            return false;\n        },\n        canMapOver: function(other) {\n            return false;\n        },\n        toString: function() {\n            return \"NullCollectionType[]\";\n        },\n        append: function(otherCollectionType) {\n            return otherCollectionType;\n        },\n        equal: function(other) {\n            return other === this;\n        }\n    };\n\n    var ANY_COLLECTION_TYPE_DESCRIPTION = {\n        isCollection: true,\n        canMatch: function(other) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n        },\n        canMapOver: function(other) {\n            return false;\n        },\n        toString: function() {\n            return \"AnyCollectionType[]\";\n        },\n        append: function(otherCollectionType) {\n            throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n        },\n        equal: function(other) {\n            return other === this;\n        }\n    };\n\n    $.extend(CollectionTypeDescription.prototype, {\n        append: function(otherCollectionTypeDescription) {\n            if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n                return this;\n            }\n            if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n                return otherCollectionType;\n            }\n            return new CollectionTypeDescription(\n                this.collectionType + \":\" + otherCollectionTypeDescription.collectionType\n            );\n        },\n        canMatch: function(otherCollectionTypeDescription) {\n            if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n                return false;\n            }\n            if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n                return true;\n            }\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        canMapOver: function(otherCollectionTypeDescription) {\n            if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n                return false;\n            }\n            if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n                return false;\n            }\n            if (this.rank <= otherCollectionTypeDescription.rank) {\n                // Cannot map over self...\n                return false;\n            }\n            var requiredSuffix = otherCollectionTypeDescription.collectionType;\n            return this._endsWith(this.collectionType, requiredSuffix);\n        },\n        effectiveMapOver: function(otherCollectionTypeDescription) {\n            var otherCollectionType = otherCollectionTypeDescription.collectionType;\n            var effectiveCollectionType = this.collectionType.substring(\n                0,\n                this.collectionType.length - otherCollectionType.length - 1\n            );\n            return new CollectionTypeDescription(effectiveCollectionType);\n        },\n        equal: function(otherCollectionTypeDescription) {\n            return otherCollectionTypeDescription.collectionType == this.collectionType;\n        },\n        toString: function() {\n            return \"CollectionType[\" + this.collectionType + \"]\";\n        },\n        _endsWith: function(str, suffix) {\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\n        }\n    });\n\n    var TerminalMapping = Backbone.Model.extend({\n        initialize: function(attr) {\n            this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n            this.terminal = attr.terminal;\n            this.terminal.terminalMapping = this;\n        },\n        disableMapOver: function() {\n            this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n        },\n        setMapOver: function(collectionTypeDescription) {\n            // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n            // event?\n            this.mapOver = collectionTypeDescription;\n            this.trigger(\"change\");\n        }\n    });\n\n    var Terminal = Backbone.Model.extend({\n        initialize: function(attr) {\n            this.element = attr.element;\n            this.connectors = [];\n        },\n        connect: function(connector) {\n            this.connectors.push(connector);\n            if (this.node) {\n                this.node.markChanged();\n            }\n        },\n        disconnect: function(connector) {\n            this.connectors.splice($.inArray(connector, this.connectors), 1);\n            if (this.node) {\n                this.node.markChanged();\n                this.resetMappingIfNeeded();\n            }\n        },\n        redraw: function() {\n            $.each(this.connectors, function(_, c) {\n                c.redraw();\n            });\n        },\n        destroy: function() {\n            $.each(this.connectors.slice(), function(_, c) {\n                c.destroy();\n            });\n        },\n        destroyInvalidConnections: function() {\n            _.each(this.connectors, function(connector) {\n                connector && connector.destroyIfInvalid();\n            });\n        },\n        setMapOver: function(val) {\n            if (this.multiple) {\n                return; // Cannot set this to be multirun...\n            }\n\n            if (!this.mapOver().equal(val)) {\n                this.terminalMapping.setMapOver(val);\n                _.each(this.node.output_terminals, function(outputTerminal) {\n                    outputTerminal.setMapOver(val);\n                });\n            }\n        },\n        mapOver: function() {\n            if (!this.terminalMapping) {\n                return NULL_COLLECTION_TYPE_DESCRIPTION;\n            } else {\n                return this.terminalMapping.mapOver;\n            }\n        },\n        isMappedOver: function() {\n            return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n        },\n\n        resetMappingIfNeeded: function() {} // Subclasses should override this...\n    });\n\n    var OutputTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.datatypes = attr.datatypes;\n        },\n\n        resetMappingIfNeeded: function() {\n            // If inputs were only mapped over to preserve\n            // an output just disconnected reset these...\n            if (!this.node.hasConnectedOutputTerminals() && !this.node.hasConnectedMappedInputTerminals()) {\n                _.each(this.node.mappedInputTerminals(), function(mappedInput) {\n                    mappedInput.resetMappingIfNeeded();\n                });\n            }\n\n            var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n            if (noMappedInputs) {\n                this.resetMapping();\n            }\n        },\n\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            _.each(this.connectors, function(connector) {\n                var connectedInput = connector.handle2;\n                if (connectedInput) {\n                    // Not exactly right because this is still connected.\n                    // Either rewrite resetMappingIfNeeded or disconnect\n                    // and reconnect if valid.\n                    connectedInput.resetMappingIfNeeded();\n                    connector.destroyIfInvalid();\n                }\n            });\n        }\n    });\n\n    var BaseInputTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.update(attr.input); // subclasses should implement this...\n        },\n        canAccept: function(other) {\n            if (this._inputFilled()) {\n                return false;\n            } else {\n                return this.attachable(other);\n            }\n        },\n        resetMappingIfNeeded: function() {\n            var mapOver = this.mapOver();\n            if (!mapOver.isCollection) {\n                return;\n            }\n            // No output terminals are counting on this being mapped\n            // over if connected inputs are still mapped over or if none\n            // of the outputs are connected...\n            var reset = this.node.hasConnectedMappedInputTerminals() || !this.node.hasConnectedOutputTerminals();\n            if (reset) {\n                this.resetMapping();\n            }\n        },\n        resetMapping: function() {\n            this.terminalMapping.disableMapOver();\n            if (!this.node.hasMappedOverInputTerminals()) {\n                _.each(this.node.output_terminals, function(terminal) {\n                    // This shouldn't be called if there are mapped over\n                    // outputs.\n                    terminal.resetMapping();\n                });\n            }\n        },\n        connected: function() {\n            return this.connectors.length !== 0;\n        },\n        _inputFilled: function() {\n            var inputFilled;\n            if (!this.connected()) {\n                inputFilled = false;\n            } else {\n                if (this.multiple) {\n                    if (this._collectionAttached()) {\n                        // Can only attach one collection to multiple input\n                        // data parameter.\n                        inputsFilled = true;\n                    } else {\n                        inputFilled = false;\n                    }\n                } else {\n                    inputFilled = true;\n                }\n            }\n            return inputFilled;\n        },\n        _collectionAttached: function() {\n            if (!this.connected()) {\n                return false;\n            } else {\n                var firstOutput = this.connectors[0].handle1;\n                if (!firstOutput) {\n                    return false;\n                } else {\n                    if (\n                        firstOutput.isCollection ||\n                        firstOutput.isMappedOver() ||\n                        firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                    ) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        _mappingConstraints: function() {\n            // If this is a connected terminal, return list of collection types\n            // other terminals connected to node are constraining mapping to.\n            if (!this.node) {\n                return []; // No node - completely unconstrained\n            }\n            var mapOver = this.mapOver();\n            if (mapOver.isCollection) {\n                return [mapOver];\n            }\n\n            var constraints = [];\n            if (!this.node.hasConnectedOutputTerminals()) {\n                _.each(this.node.connectedMappedInputTerminals(), function(inputTerminal) {\n                    constraints.push(inputTerminal.mapOver());\n                });\n            } else {\n                // All outputs should have same mapOver status - least specific.\n                constraints.push(_.first(_.values(this.node.output_terminals)).mapOver());\n            }\n            return constraints;\n        },\n        _producesAcceptableDatatype: function(other) {\n            // other is a non-collection output...\n            for (var t in this.datatypes) {\n                var thisDatatype = this.datatypes[t];\n                if (thisDatatype == \"input\") {\n                    return true;\n                }\n                var cat_outputs = new Array();\n                cat_outputs = cat_outputs.concat(other.datatypes);\n                if (other.node.post_job_actions) {\n                    for (var pja_i in other.node.post_job_actions) {\n                        var pja = other.node.post_job_actions[pja_i];\n                        if (\n                            pja.action_type == \"ChangeDatatypeAction\" &&\n                            (pja.output_name == \"\" || pja.output_name == other.name) &&\n                            pja.action_arguments\n                        ) {\n                            cat_outputs.push(pja.action_arguments[\"newtype\"]);\n                        }\n                    }\n                }\n                // FIXME: No idea what to do about case when datatype is 'input'\n                for (var other_datatype_i in cat_outputs) {\n                    var other_datatype = cat_outputs[other_datatype_i];\n                    if (\n                        other_datatype == \"input\" ||\n                        other_datatype == \"_sniff_\" ||\n                        other_datatype == \"input_collection\" ||\n                        Globals.app.isSubType(cat_outputs[other_datatype_i], thisDatatype)\n                    ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        _otherCollectionType: function(other) {\n            var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n            if (other.isCollection) {\n                otherCollectionType = other.collectionType;\n            }\n            var otherMapOver = other.mapOver();\n            if (otherMapOver.isCollection) {\n                otherCollectionType = otherMapOver.append(otherCollectionType);\n            }\n            return otherCollectionType;\n        }\n    });\n\n    var InputTerminal = BaseInputTerminal.extend({\n        update: function(input) {\n            this.datatypes = input.extensions;\n            this.multiple = input.multiple;\n            this.collection = false;\n        },\n        connect: function(connector) {\n            BaseInputTerminal.prototype.connect.call(this, connector);\n            var other_output = connector.handle1;\n            if (!other_output) {\n                return;\n            }\n            var otherCollectionType = this._otherCollectionType(other_output);\n            if (otherCollectionType.isCollection) {\n                this.setMapOver(otherCollectionType);\n            }\n        },\n        attachable: function(other) {\n            var otherCollectionType = this._otherCollectionType(other);\n            var thisMapOver = this.mapOver();\n            if (otherCollectionType.isCollection) {\n                if (this.multiple) {\n                    if (this.connected() && !this._collectionAttached()) {\n                        // if single inputs attached, cannot also attach a\n                        // collection (yet...)\n                        return false;\n                    }\n                    if (otherCollectionType.rank == 1) {\n                        return this._producesAcceptableDatatype(other);\n                    } else {\n                        // TODO: Allow subcollection mapping over this as if it were\n                        // a list collection input.\n                        return false;\n                    }\n                }\n                if (thisMapOver.isCollection && thisMapOver.canMatch(otherCollectionType)) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if (mappingConstraints.every(_.bind(otherCollectionType.canMatch, otherCollectionType))) {\n                        return this._producesAcceptableDatatype(other);\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (thisMapOver.isCollection) {\n                // Attempting to match a non-collection output to an\n                // explicitly collection input.\n                return false;\n            }\n            return this._producesAcceptableDatatype(other);\n        }\n    });\n\n    var InputCollectionTerminal = BaseInputTerminal.extend({\n        update: function(input) {\n            this.multiple = false;\n            this.collection = true;\n            this.datatypes = input.extensions;\n            var collectionTypes = [];\n            if (input.collection_types) {\n                _.each(input.collection_types, function(collectionType) {\n                    collectionTypes.push(new CollectionTypeDescription(collectionType));\n                });\n            } else {\n                collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n            }\n            this.collectionTypes = collectionTypes;\n        },\n        connect: function(connector) {\n            BaseInputTerminal.prototype.connect.call(this, connector);\n            var other = connector.handle1;\n            if (!other) {\n                return;\n            }\n\n            var effectiveMapOver = this._effectiveMapOver(other);\n            this.setMapOver(effectiveMapOver);\n        },\n        _effectiveMapOver: function(other) {\n            var collectionTypes = this.collectionTypes;\n            var otherCollectionType = this._otherCollectionType(other);\n            var canMatch = _.some(collectionTypes, function(collectionType) {\n                return collectionType.canMatch(otherCollectionType);\n            });\n\n            if (!canMatch) {\n                for (var collectionTypeIndex in collectionTypes) {\n                    var collectionType = collectionTypes[collectionTypeIndex];\n                    if (otherCollectionType.canMapOver(collectionType)) {\n                        var effectiveMapOver = otherCollectionType.effectiveMapOver(collectionType);\n                        if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                            return effectiveMapOver;\n                        }\n                    }\n                }\n            }\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        },\n        _effectiveCollectionTypes: function() {\n            var thisMapOver = this.mapOver();\n            return _.map(this.collectionTypes, function(t) {\n                return thisMapOver.append(t);\n            });\n        },\n        attachable: function(other) {\n            var otherCollectionType = this._otherCollectionType(other);\n            if (otherCollectionType.isCollection) {\n                var effectiveCollectionTypes = this._effectiveCollectionTypes();\n                var thisMapOver = this.mapOver();\n                var canMatch = _.some(effectiveCollectionTypes, function(effectiveCollectionType) {\n                    return effectiveCollectionType.canMatch(otherCollectionType);\n                });\n                if (canMatch) {\n                    // Only way a direct match...\n                    return this._producesAcceptableDatatype(other);\n                    // Otherwise we need to mapOver\n                } else if (thisMapOver.isCollection) {\n                    // In this case, mapOver already set and we didn't match skipping...\n                    return false;\n                } else if (\n                    _.some(this.collectionTypes, function(collectionType) {\n                        return otherCollectionType.canMapOver(collectionType);\n                    })\n                ) {\n                    var effectiveMapOver = this._effectiveMapOver(other);\n                    if (!effectiveMapOver.isCollection) {\n                        return false;\n                    }\n                    //  Need to check if this would break constraints...\n                    var mappingConstraints = this._mappingConstraints();\n                    if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                        return this._producesAcceptableDatatype(other);\n                    }\n                }\n            }\n            return false;\n        }\n    });\n\n    var OutputCollectionTerminal = Terminal.extend({\n        initialize: function(attr) {\n            Terminal.prototype.initialize.call(this, attr);\n            this.datatypes = attr.datatypes;\n            if (attr.collection_type) {\n                this.collectionType = new CollectionTypeDescription(attr.collection_type);\n            } else {\n                var collectionTypeSource = attr.collection_type_source;\n                if (!collectionTypeSource) {\n                    console.log(\"Warning: No collection type or collection type source defined.\");\n                }\n                this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n            }\n            this.isCollection = true;\n        },\n        update: function(output) {\n            var newCollectionType;\n            if (output.collection_type) {\n                newCollectionType = new CollectionTypeDescription(output.collection_type);\n            } else {\n                var collectionTypeSource = output.collection_type_source;\n                if (!collectionTypeSource) {\n                    console.log(\"Warning: No collection type or collection type source defined.\");\n                }\n                newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n            }\n\n            if (newCollectionType.collectionType != this.collectionType.collectionType) {\n                _.each(this.connectors, function(connector) {\n                    // TODO: consider checking if connection valid before removing...\n                    connector.destroy();\n                });\n            }\n            this.collectionType = newCollectionType;\n        }\n    });\n\n    return {\n        InputTerminal: InputTerminal,\n        OutputTerminal: OutputTerminal,\n        InputCollectionTerminal: InputCollectionTerminal,\n        OutputCollectionTerminal: OutputCollectionTerminal,\n        TerminalMapping: TerminalMapping,\n\n        // test export\n        CollectionTypeDescription: CollectionTypeDescription,\n        NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n        ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n    };\n});\n"]}