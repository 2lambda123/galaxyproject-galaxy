{"version":3,"sources":["mvc/dataset/dataset-model.js"],"names":["define","STATES","BASE_MVC","_l","logNamespace","SearchableModelMixin","DatasetAssociation","Backbone","Model","extend","LoggableMixin","mixin","_logNamespace","defaults","NEW","deleted","purged","name","accessible","data_type","file_ext","file_size","meta_files","misc_blurb","misc_info","tags","initialize","attributes","debug","this","options","get","set","NOT_VIEWABLE","urls","_generateUrls","_setUpListeners","id","purge","display","edit","download","_downloadQueryParameters","report_error","rerun","show_params","visualization","meta_download","key","Galaxy","root","value","on","currModel","newState","log","inReadyState","trigger","previous","toJSON","json","prototype","call","_","isDeletedOrPurged","ready","contains","READY_STATES","hasDetails","has","hasData","fetch","dataset","always","parse","response","parsed","create_time","update_time","save","attrs","wait","isUndefined","delete","when","undelete","jQuery","url","hda","ajax","xhr","done","message","status","responseObj","fail","error","responseJSON","responseText","messageBuriedInUnfortunatelyFormattedError","searchAttributes","title","database","description","info","tag","nameAndId","DatasetAssociationCollection","Collection","urlRoot","ids","map","item","notReady","filter","content","haveDetails","all","ajaxQueue","responses","ajaxFn","deferred","Deferred","startingLength","length","resolve","ajaxFns","chain","notify","i","curr","total","model","push","shift","matches","matchesWhat","toString","join"],"mappings":"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","file":"../../../scripts/mvc/dataset/dataset-model.js","sourcesContent":["define([\"mvc/dataset/states\", \"mvc/base-mvc\", \"utils/localization\"], function(STATES, BASE_MVC, _l) {\n    \"use strict\";\n\n    var logNamespace = \"dataset\";\n    //==============================================================================\n    var searchableMixin = BASE_MVC.SearchableModelMixin;\n    /** @class base model for any DatasetAssociation (HDAs, LDDAs, DatasetCollectionDAs).\n *      No knowledge of what type (HDA/LDDA/DCDA) should be needed here.\n *  The DA's are made searchable (by attribute) by mixing in SearchableModelMixin.\n */\n    var DatasetAssociation = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n        BASE_MVC.mixin(\n            searchableMixin,\n            /** @lends DatasetAssociation.prototype */ {\n                _logNamespace: logNamespace,\n\n                /** default attributes for a model */\n                defaults: {\n                    state: STATES.NEW,\n                    deleted: false,\n                    purged: false,\n                    name: \"(unnamed dataset)\",\n                    accessible: true,\n                    // sniffed datatype (sam, tabular, bed, etc.)\n                    data_type: \"\",\n                    file_ext: \"\",\n                    file_size: 0,\n\n                    // array of associated file types (eg. [ 'bam_index', ... ])\n                    meta_files: [],\n\n                    misc_blurb: \"\",\n                    misc_info: \"\",\n\n                    tags: []\n                    // do NOT default on annotation, as this default is valid and will be passed on 'save'\n                    //  which is incorrect behavior when the model is only partially fetched (annos are not passed in summary data)\n                    //annotation          : ''\n                },\n\n                /** instance vars and listeners */\n                initialize: function(attributes, options) {\n                    this.debug(this + \"(Dataset).initialize\", attributes, options);\n\n                    //!! this state is not in trans.app.model.Dataset.states - set it here -\n                    if (!this.get(\"accessible\")) {\n                        this.set(\"state\", STATES.NOT_VIEWABLE);\n                    }\n\n                    /** Datasets rely/use some web controllers - have the model generate those URLs on startup */\n                    this.urls = this._generateUrls();\n\n                    this._setUpListeners();\n                },\n\n                /** returns misc. web urls for rendering things like re-run, display, etc. */\n                _generateUrls: function() {\n                    var id = this.get(\"id\");\n                    if (!id) {\n                        return {};\n                    }\n                    var urls = {\n                        purge: \"datasets/\" + id + \"/purge_async\",\n                        display: \"datasets/\" + id + \"/display/?preview=True\",\n                        edit: \"datasets/edit?dataset_id=\" + id,\n                        download: \"datasets/\" + id + \"/display\" + this._downloadQueryParameters(),\n                        report_error: \"dataset/errors?id=\" + id,\n                        rerun: \"tool_runner/rerun?id=\" + id,\n                        show_params: \"datasets/\" + id + \"/show_params\",\n                        visualization: \"visualization\",\n                        meta_download: \"dataset/get_metadata_file?hda_id=\" + id + \"&metadata_name=\"\n                    };\n                    _.each(urls, function(value, key) {\n                        urls[key] = Galaxy.root + value;\n                    });\n                    this.urls = urls;\n                    return urls;\n                },\n\n                _downloadQueryParameters: function() {\n                    return \"?to_ext=\" + this.get(\"file_ext\");\n                },\n\n                /** set up any event listeners\n     *  event: state:ready  fired when this DA moves into/is already in a ready state\n     */\n                _setUpListeners: function() {\n                    // if the state has changed and the new state is a ready state, fire an event\n                    this.on(\"change:state\", function(currModel, newState) {\n                        this.log(this + \" has changed state:\", currModel, newState);\n                        if (this.inReadyState()) {\n                            this.trigger(\"state:ready\", currModel, newState, this.previous(\"state\"));\n                        }\n                    });\n                    // the download url (currently) relies on having a correct file extension\n                    this.on(\"change:id change:file_ext\", function(currModel) {\n                        this._generateUrls();\n                    });\n                },\n\n                // ........................................................................ common queries\n                /** override to add urls */\n                toJSON: function() {\n                    var json = Backbone.Model.prototype.toJSON.call(this);\n                    //console.warn( 'returning json?' );\n                    //return json;\n                    return _.extend(json, {\n                        urls: this.urls\n                    });\n                },\n\n                /** Is this dataset deleted or purged? */\n                isDeletedOrPurged: function() {\n                    return this.get(\"deleted\") || this.get(\"purged\");\n                },\n\n                /** Is this dataset in a 'ready' state; where 'Ready' states are states where no\n     *      processing (for the ds) is left to do on the server.\n     */\n                inReadyState: function() {\n                    var ready = _.contains(STATES.READY_STATES, this.get(\"state\"));\n                    return this.isDeletedOrPurged() || ready;\n                },\n\n                /** Does this model already contain detailed data (as opposed to just summary level data)? */\n                hasDetails: function() {\n                    // if it's inaccessible assume it has everything it needs\n                    if (!this.get(\"accessible\")) {\n                        return true;\n                    }\n                    return this.has(\"annotation\");\n                },\n\n                /** Convenience function to match dataset.has_data. */\n                hasData: function() {\n                    return this.get(\"file_size\") > 0;\n                },\n\n                // ........................................................................ ajax\n                fetch: function(options) {\n                    var dataset = this;\n                    return Backbone.Model.prototype.fetch.call(this, options).always(function() {\n                        dataset._generateUrls();\n                    });\n                },\n\n                /** override to use actual Dates objects for create/update times */\n                parse: function(response, options) {\n                    var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                    if (parsed.create_time) {\n                        parsed.create_time = new Date(parsed.create_time);\n                    }\n                    if (parsed.update_time) {\n                        parsed.update_time = new Date(parsed.update_time);\n                    }\n                    return parsed;\n                },\n\n                /** override to wait by default */\n                save: function(attrs, options) {\n                    options = options || {};\n                    options.wait = _.isUndefined(options.wait) ? true : options.wait;\n                    return Backbone.Model.prototype.save.call(this, attrs, options);\n                },\n\n                //NOTE: subclasses of DA's will need to implement url and urlRoot in order to have these work properly\n                /** save this dataset, _Mark_ing it as deleted (just a flag) */\n                delete: function(options) {\n                    if (this.get(\"deleted\")) {\n                        return jQuery.when();\n                    }\n                    return this.save({ deleted: true }, options);\n                },\n                /** save this dataset, _Mark_ing it as undeleted */\n                undelete: function(options) {\n                    if (!this.get(\"deleted\") || this.get(\"purged\")) {\n                        return jQuery.when();\n                    }\n                    return this.save({ deleted: false }, options);\n                },\n\n                /** remove the file behind this dataset from the filesystem (if permitted) */\n                purge: function _purge(options) {\n                    //TODO: use, override model.destroy, HDA.delete({ purge: true })\n                    if (this.get(\"purged\")) {\n                        return jQuery.when();\n                    }\n                    options = options || {};\n                    options.url = this.urls.purge;\n\n                    //TODO: ideally this would be a DELETE call to the api\n                    //  using purge async for now\n                    var hda = this,\n                        xhr = jQuery.ajax(options);\n                    xhr.done(function(message, status, responseObj) {\n                        hda.set({ deleted: true, purged: true });\n                    });\n                    xhr.fail(function(xhr, status, message) {\n                        // Exception messages are hidden within error page including:  '...not allowed in this Galaxy instance.'\n                        // unbury and re-add to xhr\n                        var error = _l(\"Unable to purge dataset\");\n                        var messageBuriedInUnfortunatelyFormattedError =\n                            \"Removal of datasets by users \" + \"is not allowed in this Galaxy instance\";\n                        if (xhr.responseJSON && xhr.responseJSON.error) {\n                            error = xhr.responseJSON.error;\n                        } else if (xhr.responseText.indexOf(messageBuriedInUnfortunatelyFormattedError) !== -1) {\n                            error = messageBuriedInUnfortunatelyFormattedError;\n                        }\n                        xhr.responseText = error;\n                        hda.trigger(\"error\", hda, xhr, options, _l(error), {\n                            error: error\n                        });\n                    });\n                    return xhr;\n                },\n\n                // ........................................................................ searching\n                /** what attributes of an HDA will be used in a text search */\n                searchAttributes: [\"name\", \"file_ext\", \"genome_build\", \"misc_blurb\", \"misc_info\", \"annotation\", \"tags\"],\n\n                /** our attr keys don't often match the labels we display to the user - so, when using\n     *      attribute specifiers ('name=\"bler\"') in a term, allow passing in aliases for the\n     *      following attr keys.\n     */\n                searchAliases: {\n                    title: \"name\",\n                    format: \"file_ext\",\n                    database: \"genome_build\",\n                    blurb: \"misc_blurb\",\n                    description: \"misc_blurb\",\n                    info: \"misc_info\",\n                    tag: \"tags\"\n                },\n\n                // ........................................................................ misc\n                /** String representation */\n                toString: function() {\n                    var nameAndId = this.get(\"id\") || \"\";\n                    if (this.get(\"name\")) {\n                        nameAndId = '\"' + this.get(\"name\") + '\",' + nameAndId;\n                    }\n                    return \"Dataset(\" + nameAndId + \")\";\n                }\n            }\n        )\n    );\n\n    //==============================================================================\n    /** @class Backbone collection for dataset associations.\n */\n    var DatasetAssociationCollection = Backbone.Collection.extend(BASE_MVC.LoggableMixin).extend(\n        /** @lends HistoryContents.prototype */ {\n            _logNamespace: logNamespace,\n\n            model: DatasetAssociation,\n\n            /** root api url */\n            urlRoot: Galaxy.root + \"api/datasets\",\n\n            /** url fn */\n            url: function() {\n                return this.urlRoot;\n            },\n\n            // ........................................................................ common queries\n            /** Get the ids of every item in this collection\n     *  @returns array of encoded ids\n     */\n            ids: function() {\n                return this.map(function(item) {\n                    return item.get(\"id\");\n                });\n            },\n\n            /** Get contents that are not ready\n     *  @returns array of content models\n     */\n            notReady: function() {\n                return this.filter(function(content) {\n                    return !content.inReadyState();\n                });\n            },\n\n            /** return true if any datasets don't have details */\n            haveDetails: function() {\n                return this.all(function(dataset) {\n                    return dataset.hasDetails();\n                });\n            },\n\n            // ........................................................................ ajax\n            /** using a queue, perform ajaxFn on each of the models in this collection */\n            ajaxQueue: function(ajaxFn, options) {\n                var deferred = jQuery.Deferred(),\n                    startingLength = this.length,\n                    responses = [];\n\n                if (!startingLength) {\n                    deferred.resolve([]);\n                    return deferred;\n                }\n\n                // use reverse order (stylistic choice)\n                var ajaxFns = this.chain()\n                    .reverse()\n                    .map(function(dataset, i) {\n                        return function() {\n                            var xhr = ajaxFn.call(dataset, options);\n                            // if successful, notify using the deferred to allow tracking progress\n                            xhr.done(function(response) {\n                                deferred.notify({\n                                    curr: i,\n                                    total: startingLength,\n                                    response: response,\n                                    model: dataset\n                                });\n                            });\n                            // (regardless of previous error or success) if not last ajax call, shift and call the next\n                            //  if last fn, resolve deferred\n                            xhr.always(function(response) {\n                                responses.push(response);\n                                if (ajaxFns.length) {\n                                    ajaxFns.shift()();\n                                } else {\n                                    deferred.resolve(responses);\n                                }\n                            });\n                        };\n                    })\n                    .value();\n                // start the queue\n                ajaxFns.shift()();\n\n                return deferred;\n            },\n\n            // ........................................................................ sorting/filtering\n            /** return a new collection of datasets whose attributes contain the substring matchesWhat */\n            matches: function(matchesWhat) {\n                return this.filter(function(dataset) {\n                    return dataset.matches(matchesWhat);\n                });\n            },\n\n            /** String representation. */\n            toString: function() {\n                return [\"DatasetAssociationCollection(\", this.length, \")\"].join(\"\");\n            }\n        }\n    );\n\n    //==============================================================================\n    return {\n        DatasetAssociation: DatasetAssociation,\n        DatasetAssociationCollection: DatasetAssociationCollection\n    };\n});\n"]}