{"version":3,"sources":["mvc/base/controlled-fetch-collection.js"],"names":["define","_","Backbone","BASE_MVC","ControlledFetchCollection","Collection","extend","initialize","models","options","this","setOrder","order","silent","_setUpListeners","on","changed-order","sort","fetch","_buildFetchOptions","Galaxy","debug","prototype","call","self","data","_buildFetchData","_buildFetchFilters","filters","isEmpty","defaults","pick","_fetchParams","_fetchFiltersToAjaxData","q","filterMap","qv","v","k","undefined","push","reset","allFetched","comparators","update_time","buildComparator","ascending","collection","comparator","trigger","PaginatedCollection","limitPerPage","currentPage","getTotalItemCount","length","shouldPaginate","getLastPage","Math","floor","getPageCount","getPageLimitOffset","pageNum","constrainPageNum","offset","max","min","fetchPage","always","fetchCurrentPage","fetchPrevPage","fetchNextPage","InfinitelyScrollingCollection","limitOnFirstFetch","limitPerFetch","lastFetched","remove","fetchFirst","clone","fetchMore","jQuery","when","limit","_postFetchMore","fetchedData","numFetched","isArray","fetchAll","done"],"mappings":"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","file":"../../../scripts/mvc/base/controlled-fetch-collection.js","sourcesContent":["define([\"libs/underscore\", \"libs/backbone\", \"mvc/base-mvc\"], function(_, Backbone, BASE_MVC) {\n    \"use strict\";\n\n    //=============================================================================\n    /**\n * A Collection that can be limited/offset/re-ordered/filtered.\n * @type {Backbone.Collection}\n */\n    var ControlledFetchCollection = Backbone.Collection.extend({\n        /** call setOrder on initialization to build the comparator based on options */\n        initialize: function(models, options) {\n            Backbone.Collection.prototype.initialize.call(this, models, options);\n            this.setOrder(options.order || this.order, { silent: true });\n        },\n\n        /** set up to track order changes and re-sort when changed */\n        _setUpListeners: function() {\n            return this.on({\n                \"changed-order\": this.sort\n            });\n        },\n\n        /** override to provide order and offsets based on instance vars, set limit if passed,\n     *  and set allFetched/fire 'all-fetched' when xhr returns\n     */\n        fetch: function(options) {\n            options = this._buildFetchOptions(options);\n            Galaxy.debug(\"fetch options:\", options);\n            return Backbone.Collection.prototype.fetch.call(this, options);\n        },\n\n        /** build ajax data/parameters from options */\n        _buildFetchOptions: function(options) {\n            // note: we normally want options passed in to override the defaults built here\n            // so most of these fns will generate defaults\n            options = _.clone(options) || {};\n            var self = this;\n\n            // jquery ajax option; allows multiple q/qv for filters (instead of 'q[]')\n            options.traditional = true;\n\n            // options.data\n            // we keep limit, offset, etc. in options *as well as move it into data* because:\n            // - it makes fetch calling convenient to add it to a single options map (instead of as mult. args)\n            // - it allows the std. event handlers (for fetch, etc.) to have access\n            //   to the pagination options too\n            //      (i.e. this.on( 'sync', function( options ){ if( options.limit ){ ... } }))\n            // however, when we send to xhr/jquery we copy them to data also so that they become API query params\n            options.data = options.data || self._buildFetchData(options);\n            Galaxy.debug(\"data:\", options.data);\n\n            // options.data.filters --> options.data.q, options.data.qv\n            var filters = this._buildFetchFilters(options);\n            Galaxy.debug(\"filters:\", filters);\n            if (!_.isEmpty(filters)) {\n                _.extend(options.data, this._fetchFiltersToAjaxData(filters));\n            }\n            Galaxy.debug(\"data:\", options.data);\n            return options;\n        },\n\n        /** Build the dictionary to send to fetch's XHR as data */\n        _buildFetchData: function(options) {\n            var defaults = {};\n            if (this.order) {\n                defaults.order = this.order;\n            }\n            return _.defaults(_.pick(options, this._fetchParams), defaults);\n        },\n\n        /** These attribute keys are valid params to fetch/API-index */\n        _fetchParams: [\n            /** model dependent string to control the order of models returned */\n            \"order\",\n            /** limit the number of models returned from a fetch */\n            \"limit\",\n            /** skip this number of models when fetching */\n            \"offset\",\n            /** what series of attributes to return (model dependent) */\n            \"view\",\n            /** individual keys to return for the models (see api/histories.index) */\n            \"keys\"\n        ],\n\n        /** add any needed filters here based on collection state */\n        _buildFetchFilters: function(options) {\n            // override\n            return _.clone(options.filters || {});\n        },\n\n        /** Convert dictionary filters to qqv style arrays */\n        _fetchFiltersToAjaxData: function(filters) {\n            // return as a map so ajax.data can extend from it\n            var filterMap = {\n                q: [],\n                qv: []\n            };\n            _.each(filters, function(v, k) {\n                // don't send if filter value is empty\n                if (v === undefined || v === \"\") {\n                    return;\n                }\n                // json to python\n                if (v === true) {\n                    v = \"True\";\n                }\n                if (v === false) {\n                    v = \"False\";\n                }\n                if (v === null) {\n                    v = \"None\";\n                }\n                // map to k/v arrays (q/qv)\n                filterMap.q.push(k);\n                filterMap.qv.push(v);\n            });\n            return filterMap;\n        },\n\n        /** override to reset allFetched flag to false */\n        reset: function(models, options) {\n            this.allFetched = false;\n            return Backbone.Collection.prototype.reset.call(this, models, options);\n        },\n\n        // ........................................................................ order\n        order: null,\n\n        /** @type {Object} map of collection available sorting orders containing comparator fns */\n        comparators: {\n            update_time: BASE_MVC.buildComparator(\"update_time\", {\n                ascending: false\n            }),\n            \"update_time-asc\": BASE_MVC.buildComparator(\"update_time\", {\n                ascending: true\n            }),\n            create_time: BASE_MVC.buildComparator(\"create_time\", {\n                ascending: false\n            }),\n            \"create_time-asc\": BASE_MVC.buildComparator(\"create_time\", {\n                ascending: true\n            })\n        },\n\n        /** set the order and comparator for this collection then sort with the new order\n     *  @event 'changed-order' passed the new order and the collection\n     */\n        setOrder: function(order, options) {\n            options = options || {};\n            var collection = this;\n            var comparator = collection.comparators[order];\n            if (_.isUndefined(comparator)) {\n                throw new Error(\"unknown order: \" + order);\n            }\n            // if( _.isUndefined( comparator ) ){ return; }\n            if (comparator === collection.comparator) {\n                return;\n            }\n\n            collection.order = order;\n            collection.comparator = comparator;\n\n            if (!options.silent) {\n                collection.trigger(\"changed-order\", options);\n            }\n            return collection;\n        }\n    });\n\n    //=============================================================================\n    /**\n *\n */\n    var PaginatedCollection = ControlledFetchCollection.extend({\n        /** @type {Number} limit used for each page's fetch */\n        limitPerPage: 500,\n\n        initialize: function(models, options) {\n            ControlledFetchCollection.prototype.initialize.call(this, models, options);\n            this.currentPage = options.currentPage || 0;\n        },\n\n        getTotalItemCount: function() {\n            return this.length;\n        },\n\n        shouldPaginate: function() {\n            return this.getTotalItemCount() >= this.limitPerPage;\n        },\n\n        getLastPage: function() {\n            return Math.floor(this.getTotalItemCount() / this.limitPerPage);\n        },\n\n        getPageCount: function() {\n            return this.getLastPage() + 1;\n        },\n\n        getPageLimitOffset: function(pageNum) {\n            pageNum = this.constrainPageNum(pageNum);\n            return {\n                limit: this.limitPerPage,\n                offset: pageNum * this.limitPerPage\n            };\n        },\n\n        constrainPageNum: function(pageNum) {\n            return Math.max(0, Math.min(pageNum, this.getLastPage()));\n        },\n\n        /** fetch the next page of data */\n        fetchPage: function(pageNum, options) {\n            var self = this;\n            pageNum = self.constrainPageNum(pageNum);\n            self.currentPage = pageNum;\n            options = _.defaults(options || {}, self.getPageLimitOffset(pageNum));\n\n            self.trigger(\"fetching-more\");\n            return self.fetch(options).always(function() {\n                self.trigger(\"fetching-more-done\");\n            });\n        },\n\n        fetchCurrentPage: function(options) {\n            return this.fetchPage(this.currentPage, options);\n        },\n\n        fetchPrevPage: function(options) {\n            return this.fetchPage(this.currentPage - 1, options);\n        },\n\n        fetchNextPage: function(options) {\n            return this.fetchPage(this.currentPage + 1, options);\n        }\n    });\n\n    //=============================================================================\n    /**\n * A Collection that will load more elements without reseting.\n */\n    var InfinitelyScrollingCollection = ControlledFetchCollection.extend({\n        /** @type {Number} limit used for the first fetch (or a reset) */\n        limitOnFirstFetch: null,\n        /** @type {Number} limit used for each subsequent fetch */\n        limitPerFetch: 100,\n\n        initialize: function(models, options) {\n            ControlledFetchCollection.prototype.initialize.call(this, models, options);\n            /** @type {Integer} number of contents to return from the first fetch */\n            this.limitOnFirstFetch = options.limitOnFirstFetch || this.limitOnFirstFetch;\n            /** @type {Integer} limit for every fetch after the first */\n            this.limitPerFetch = options.limitPerFetch || this.limitPerFetch;\n            /** @type {Boolean} are all contents fetched? */\n            this.allFetched = false;\n            /** @type {Integer} what was the offset of the last content returned */\n            this.lastFetched = options.lastFetched || 0;\n        },\n\n        /** build ajax data/parameters from options */\n        _buildFetchOptions: function(options) {\n            // options (options for backbone.fetch and jquery.ajax generally)\n            // backbone option; false here to make fetching an addititive process\n            options.remove = options.remove || false;\n            return ControlledFetchCollection.prototype._buildFetchOptions.call(this, options);\n        },\n\n        /** fetch the first 'page' of data */\n        fetchFirst: function(options) {\n            Galaxy.debug(\"ControlledFetchCollection.fetchFirst:\", options);\n            options = options ? _.clone(options) : {};\n            this.allFetched = false;\n            this.lastFetched = 0;\n            return this.fetchMore(\n                _.defaults(options, {\n                    reset: true,\n                    limit: this.limitOnFirstFetch\n                })\n            );\n        },\n\n        /** fetch the next page of data */\n        fetchMore: function(options) {\n            Galaxy.debug(\"ControlledFetchCollection.fetchMore:\", options);\n            options = _.clone(options || {});\n            var collection = this;\n\n            Galaxy.debug(\"fetchMore, options.reset:\", options.reset);\n            if (!options.reset && collection.allFetched) {\n                return jQuery.when();\n            }\n\n            // TODO: this fails in the edge case where\n            //  the first fetch offset === limit (limit 4, offset 4, collection.length 4)\n            if (options.reset) {\n                options.offset = 0;\n            } else if (options.offset === undefined) {\n                options.offset = collection.lastFetched;\n            }\n            var limit = (options.limit = options.limit || collection.limitPerFetch || null);\n            Galaxy.debug(\"fetchMore, limit:\", limit, \"offset:\", options.offset);\n\n            collection.trigger(\"fetching-more\");\n            return (\n                collection\n                    .fetch(options)\n                    .always(function() {\n                        collection.trigger(\"fetching-more-done\");\n                    })\n                    // maintain allFetched flag and trigger if all were fetched this time\n                    .done(function _postFetchMore(fetchedData) {\n                        var numFetched = _.isArray(fetchedData) ? fetchedData.length : 0;\n                        collection.lastFetched += numFetched;\n                        Galaxy.debug(\"fetchMore, lastFetched:\", collection.lastFetched);\n                        // anything less than a full page means we got all there is to get\n                        if (!limit || numFetched < limit) {\n                            collection.allFetched = true;\n                            collection.trigger(\"all-fetched\", this);\n                        }\n                    })\n            );\n        },\n\n        /** fetch all the collection */\n        fetchAll: function(options) {\n            // whitelist options to prevent allowing limit/offset/filters\n            // (use vanilla fetch instead)\n            options = options || {};\n            var self = this;\n            options = _.pick(options, \"silent\");\n            options.filters = {};\n            return self.fetch(options).done(function() {\n                self.allFetched = true;\n                self.trigger(\"all-fetched\", self);\n            });\n        }\n    });\n\n    //==============================================================================\n    return {\n        ControlledFetchCollection: ControlledFetchCollection,\n        PaginatedCollection: PaginatedCollection,\n        InfinitelyScrollingCollection: InfinitelyScrollingCollection\n    };\n});\n"]}