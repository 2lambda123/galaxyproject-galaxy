{"version":3,"sources":["mvc/form/form-data.js"],"names":["define","Utils","Manager","Backbone","Model","extend","initialize","app","checksum","sum","this","$el","find","each","self","$","attr","field","field_list","id","value","collapsed","create","result_dict","input_id","input_value","flat_dict","flat_id","element_list","convert","identifier","head","index","node","input","name","type","block_indices","section_label","block_prefix","indexOf","block_label","pos","push","parseInt","substr","sort","a","b","i","add","test_param","selectedCase","matchCase","flat","undefined","ignore","collapsible_value","payload","p_id","dict","_iterate","section","match","matchModel","model","callback","inputs","matchResponse","response","result","search","new_id","Array","separator","parent","children","child","hasClass","input_list","truevalue","cases","visitInputs","prefix","context","key","cache","j","Galaxy","emit","debug"],"mappings":"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","file":"../../../scripts/mvc/form/form-data.js","sourcesContent":["/* This class maps the form dom to an api compatible javascript dictionary. */\ndefine([\"utils/utils\"], function(Utils) {\n    var Manager = Backbone.Model.extend({\n        initialize: function(app) {\n            this.app = app;\n        },\n\n        /** Creates a checksum. */\n        checksum: function() {\n            var sum = \"\";\n            var self = this;\n            this.app.section.$el.find(\".section-row\").each(function() {\n                var id = $(this).attr(\"id\");\n                var field = self.app.field_list[id];\n                if (field) {\n                    sum += id + \":\" + JSON.stringify(field.value && field.value()) + \":\" + field.collapsed + \";\";\n                }\n            });\n            return sum;\n        },\n\n        /** Convert dom into a dictionary of flat id/value pairs used e.g. on job submission. */\n        create: function() {\n            var self = this;\n\n            // get raw dictionary from dom\n            var dict = {};\n            this._iterate(this.app.section.$el, dict);\n\n            // add to result dictionary, label elements\n            var result_dict = {};\n            this.flat_dict = {};\n            function add(flat_id, input_id, input_value) {\n                self.flat_dict[flat_id] = input_id;\n                result_dict[flat_id] = input_value;\n                self.app.element_list[input_id] && self.app.element_list[input_id].$el.attr(\"tour_id\", flat_id);\n            }\n            // converter between raw dictionary and job dictionary\n            function convert(identifier, head) {\n                for (var index in head) {\n                    var node = head[index];\n                    if (node.input) {\n                        var input = node.input;\n                        var flat_id = identifier;\n                        if (identifier != \"\") {\n                            flat_id += \"|\";\n                        }\n                        flat_id += input.name;\n                        switch (input.type) {\n                            case \"repeat\":\n                                var section_label = \"section-\";\n                                var block_indices = [];\n                                var block_prefix = null;\n                                for (var block_label in node) {\n                                    var pos = block_label.indexOf(section_label);\n                                    if (pos != -1) {\n                                        pos += section_label.length;\n                                        block_indices.push(parseInt(block_label.substr(pos)));\n                                        if (!block_prefix) {\n                                            block_prefix = block_label.substr(0, pos);\n                                        }\n                                    }\n                                }\n                                block_indices.sort(function(a, b) {\n                                    return a - b;\n                                });\n                                var index = 0;\n                                for (var i in block_indices) {\n                                    convert(flat_id + \"_\" + index++, node[block_prefix + block_indices[i]]);\n                                }\n                                break;\n                            case \"conditional\":\n                                var value = self.app.field_list[input.id].value();\n                                add(flat_id + \"|\" + input.test_param.name, input.id, value);\n                                var selectedCase = matchCase(input, value);\n                                if (selectedCase != -1) {\n                                    convert(flat_id, head[input.id + \"-section-\" + selectedCase]);\n                                }\n                                break;\n                            case \"section\":\n                                convert((!input.flat && flat_id) || \"\", node);\n                                break;\n                            default:\n                                var field = self.app.field_list[input.id];\n                                if (field && field.value) {\n                                    var value = field.value();\n                                    if (input.ignore === undefined || input.ignore != value) {\n                                        if (field.collapsed && input.collapsible_value) {\n                                            value = input.collapsible_value;\n                                        }\n                                        add(flat_id, input.id, value);\n                                        if (input.payload) {\n                                            for (var p_id in input.payload) {\n                                                add(p_id, input.id, input.payload[p_id]);\n                                            }\n                                        }\n                                    }\n                                }\n                        }\n                    }\n                }\n            }\n            convert(\"\", dict);\n            return result_dict;\n        },\n\n        /** Matches flat ids to corresponding input element\n         * @param{string} flat_id - Flat input id to be looked up.\n         */\n        match: function(flat_id) {\n            return this.flat_dict && this.flat_dict[flat_id];\n        },\n\n        /** Match conditional values to selected cases\n        */\n        matchCase: function(input, value) {\n            return matchCase(input, value);\n        },\n\n        /** Matches a new tool model to the current input elements e.g. used to update dynamic options\n        */\n        matchModel: function(model, callback) {\n            var self = this;\n            visitInputs(model.inputs, function(input, name) {\n                self.flat_dict[name] && callback(input, self.flat_dict[name]);\n            });\n        },\n\n        /** Matches identifier from api response to input elements e.g. used to display validation errors\n        */\n        matchResponse: function(response) {\n            var result = {};\n            var self = this;\n            function search(id, head) {\n                if (typeof head === \"string\") {\n                    var input_id = self.flat_dict[id];\n                    input_id && (result[input_id] = head);\n                } else {\n                    for (var i in head) {\n                        var new_id = i;\n                        if (id !== \"\") {\n                            var separator = \"|\";\n                            if (head instanceof Array) {\n                                separator = \"_\";\n                            }\n                            new_id = id + separator + new_id;\n                        }\n                        search(new_id, head[i]);\n                    }\n                }\n            }\n            search(\"\", response);\n            return result;\n        },\n\n        /** Map dom tree to dictionary tree with input elements.\n        */\n        _iterate: function(parent, dict) {\n            var self = this;\n            var children = $(parent).children();\n            children.each(function() {\n                var child = this;\n                var id = $(child).attr(\"id\");\n                if ($(child).hasClass(\"section-row\")) {\n                    var input = self.app.input_list[id];\n                    dict[id] = (input && { input: input }) || {};\n                    self._iterate(child, dict[id]);\n                } else {\n                    self._iterate(child, dict);\n                }\n            });\n        }\n    });\n\n    /** Match conditional values to selected cases\n     * @param{dict}   input     - Definition of conditional input parameter\n     * @param{dict}   value     - Current value\n     */\n    var matchCase = function(input, value) {\n        if (input.test_param.type == \"boolean\") {\n            if (value == \"true\") {\n                value = input.test_param.truevalue || \"true\";\n            } else {\n                value = input.test_param.falsevalue || \"false\";\n            }\n        }\n        for (var i in input.cases) {\n            if (input.cases[i].value == value) {\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    /** Visits tool inputs\n     * @param{dict}   inputs    - Nested dictionary of input elements\n     * @param{dict}   callback  - Called with the mapped dictionary object and corresponding model node\n     */\n    var visitInputs = function(inputs, callback, prefix, context) {\n        context = $.extend(true, {}, context);\n        _.each(inputs, function(input) {\n            if (input && input.type && input.name) {\n                context[input.name] = input;\n            }\n        });\n        for (var key in inputs) {\n            var node = inputs[key];\n            node.name = node.name || key;\n            var name = prefix ? prefix + \"|\" + node.name : node.name;\n            switch (node.type) {\n                case \"repeat\":\n                    _.each(node.cache, function(cache, j) {\n                        visitInputs(cache, callback, name + \"_\" + j, context);\n                    });\n                    break;\n                case \"conditional\":\n                    if (node.test_param) {\n                        callback(node.test_param, name + \"|\" + node.test_param.name, context);\n                        var selectedCase = matchCase(node, node.test_param.value);\n                        if (selectedCase != -1) {\n                            visitInputs(node.cases[selectedCase].inputs, callback, name, context);\n                        } else {\n                            Galaxy.emit.debug(\"form-data::visitInputs() - Invalid case for \" + name + \".\");\n                        }\n                    } else {\n                        Galaxy.emit.debug(\n                            \"form-data::visitInputs() - Conditional test parameter missing for \" + name + \".\"\n                        );\n                    }\n                    break;\n                case \"section\":\n                    visitInputs(node.inputs, callback, name, context);\n                    break;\n                default:\n                    callback(node, name, context);\n            }\n        }\n    };\n\n    return {\n        Manager: Manager,\n        visitInputs: visitInputs\n    };\n});\n"]}