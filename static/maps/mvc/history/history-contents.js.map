{"version":3,"sources":["mvc/history/history-contents.js"],"names":["define","_super","CONTROLLED_FETCH_COLLECTION","HDA_MODEL","HDCA_MODEL","HISTORY_PREFS","BASE_MVC","AJAX_QUEUE","PaginatedCollection","HistoryContents","history_content_type","LoggableMixin","extend","_logNamespace","model","attrs","HistoryPairDatasetCollection","options","collection_type","HistoryListOfListsDatasetCollection","HistoryListPairedDatasetCollection","msg","console","warn","validationError","limitPerPage","order","urlRoot","url","Galaxy","root","prototype","initialize","this","historyId","models","includeDeleted","call","history","setHistoryId","includeHidden","idAttribute","_setUpWebStorage","newId","id","HistoryPrefs","trigger","name","storage","newVal","on","include-deleted","comparators","_","buildComparator","ascending","name-dsc","hid","hid-asc","inReadyState","running","runningAndActive","filter","c","get","getByHid","findWhere","haveDetails","hidden","hasDetails","deleted","setIncludeDeleted","isBoolean","setting","result","setIncludeHidden","isEmpty","prefs","fetch","_buildFetchData","details","toJSON","expandedIds","values","join","v","_fetchParams","concat","filters","_buildFetchFilters","superFilters","getTotalItemCount","purged","fetchUpdated","visible","contentsShown","since","remove","fetchDeleted","toISOString","self","fetchHidden","always","fetchAllDetails","data","detailsFlag","fetchCollectionCounts","_filterAndUpdate","keys","updateArgs","filterParams","updateWhat","collection","then","fetched","deferred","fn","isString","ajaxFn","i","currJson","apply","content","modelArray","ajaxQueue","args","jQuery","AjaxQueue","limit","slice","searchAttributes","detailKeys","_recursivelyFetch","offset","_options","clone","view","defer","copyableModelClasses","contentsJSON","fail","reject","done","response","notify","length","allFetched","contentType","resolve","Deferred","HistoryDatasetAssociation","type","xhr","ajax","method","model_class","copy","json","error","LibraryDatasetDatasetAssociation","HistoryDatasetCollectionAssociation","elementIdentifiers","hdca","collectionType","JSON","stringify","hide_source_items","hideSourceItems","source","add","parse","status","message","createHDCA","matches","history_id","save","haveSearchDetails","all","has","attributes","matchesWhat","Backbone","Collection","toString"],"mappings":"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","file":"../../../scripts/mvc/history/history-contents.js","sourcesContent":["define(\n    [\n        \"mvc/base/controlled-fetch-collection\",\n        \"mvc/history/hda-model\",\n        \"mvc/history/hdca-model\",\n        \"mvc/history/history-preferences\",\n        \"mvc/base-mvc\",\n        \"utils/ajax-queue\"\n    ],\n    function(CONTROLLED_FETCH_COLLECTION, HDA_MODEL, HDCA_MODEL, HISTORY_PREFS, BASE_MVC, AJAX_QUEUE) {\n        \"use strict\";\n\n        //==============================================================================\n        var _super = CONTROLLED_FETCH_COLLECTION.PaginatedCollection;\n        /** @class Backbone collection for history content.\n *      NOTE: history content seems like a dataset collection, but differs in that it is mixed:\n *          each element can be either an HDA (dataset) or a DatasetCollection and co-exist on\n *          the same level.\n *      Dataset collections on the other hand are not mixed and (so far) can only contain either\n *          HDAs or child dataset collections on one level.\n *      This is why this does not inherit from any of the DatasetCollections (currently).\n */\n        var HistoryContents = _super.extend(BASE_MVC.LoggableMixin).extend({\n            _logNamespace: \"history\",\n\n            // ........................................................................ composite collection\n            /** since history content is a mix, override model fn into a factory, creating based on history_content_type */\n            model: function(attrs, options) {\n                if (attrs.history_content_type === \"dataset\") {\n                    return new HDA_MODEL.HistoryDatasetAssociation(attrs, options);\n                } else if (attrs.history_content_type === \"dataset_collection\") {\n                    switch (attrs.collection_type) {\n                        case \"list\":\n                            return new HDCA_MODEL.HistoryListDatasetCollection(attrs, options);\n                        case \"paired\":\n                            return new HDCA_MODEL.HistoryPairDatasetCollection(attrs, options);\n                        case \"list:paired\":\n                            return new HDCA_MODEL.HistoryListPairedDatasetCollection(attrs, options);\n                        case \"list:list\":\n                            return new HDCA_MODEL.HistoryListOfListsDatasetCollection(attrs, options);\n                    }\n                    // This is a hack inside a hack:\n                    // Raise a plain object with validationError to fake a model.validationError\n                    // (since we don't have a model to use validate with)\n                    // (the outer hack being the mixed content/model function in this collection)\n                    var msg = \"Unknown collection_type: \" + attrs.collection_type;\n                    console.warn(msg, attrs);\n                    return { validationError: msg };\n                }\n                return {\n                    validationError: \"Unknown history_content_type: \" + attrs.history_content_type\n                };\n            },\n\n            // ........................................................................ set up\n            limitPerPage: 500,\n\n            /** @type {Integer} how many contents per call to fetch when using progressivelyFetchDetails */\n            limitPerProgressiveFetch: 500,\n\n            /** @type {String} order used here and when fetching from server */\n            order: \"hid\",\n\n            /** root api url */\n            urlRoot: Galaxy.root + \"api/histories\",\n\n            /** complete api url */\n            url: function() {\n                return this.urlRoot + \"/\" + this.historyId + \"/contents\";\n            },\n\n            /** Set up */\n            initialize: function(models, options) {\n                options = options || {};\n                _super.prototype.initialize.call(this, models, options);\n\n                this.history = options.history || null;\n                this.setHistoryId(options.historyId || null);\n                /** @type {Boolean} does this collection contain and fetch deleted elements */\n                this.includeDeleted = options.includeDeleted || this.includeDeleted;\n                /** @type {Boolean} does this collection contain and fetch non-visible elements */\n                this.includeHidden = options.includeHidden || this.includeHidden;\n\n                // backbonejs uses collection.model.prototype.idAttribute to determine if a model is *already* in a collection\n                //  and either merged or replaced. In this case, our 'model' is a function so we need to add idAttribute\n                //  manually here - if we don't, contents will not merge but be replaced/swapped.\n                this.model.prototype.idAttribute = \"type_id\";\n            },\n\n            setHistoryId: function(newId) {\n                this.historyId = newId;\n                this._setUpWebStorage();\n            },\n\n            /** Set up client side storage. Currently PersistanStorage keyed under 'history:<id>' */\n            _setUpWebStorage: function(initialSettings) {\n                // TODO: use initialSettings\n                if (!this.historyId) {\n                    return;\n                }\n                this.storage = new HISTORY_PREFS.HistoryPrefs({\n                    id: HISTORY_PREFS.HistoryPrefs.historyStorageKey(this.historyId)\n                });\n                this.trigger(\"new-storage\", this.storage, this);\n\n                this.on({\n                    \"include-deleted\": function(newVal) {\n                        this.storage.includeDeleted(newVal);\n                    },\n                    \"include-hidden\": function(newVal) {\n                        this.storage.includeHidden(newVal);\n                    }\n                });\n\n                this.includeDeleted = this.storage.includeDeleted() || false;\n                this.includeHidden = this.storage.includeHidden() || false;\n                return this;\n            },\n\n            // ........................................................................ common queries\n            /** @type {Object} map of collection available sorting orders containing comparator fns */\n            comparators: _.extend(_.clone(_super.prototype.comparators), {\n                name: BASE_MVC.buildComparator(\"name\", { ascending: true }),\n                \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n                    ascending: false\n                }),\n                hid: BASE_MVC.buildComparator(\"hid\", { ascending: false }),\n                \"hid-asc\": BASE_MVC.buildComparator(\"hid\", { ascending: true })\n            }),\n\n            /** Get every model in this collection not in a 'ready' state (running). */\n            running: function() {\n                return this.filter(function(c) {\n                    return !c.inReadyState();\n                });\n            },\n\n            /** return contents that are not ready and not deleted/hidden */\n            runningAndActive: function() {\n                return this.filter(function(c) {\n                    return (\n                        !c.inReadyState() &&\n                        c.get(\"visible\") &&\n                        // TODO: deletedOrPurged?\n                        !c.get(\"deleted\")\n                    );\n                });\n            },\n\n            /** Get the model with the given hid\n     *  @param {Int} hid the hid to search for\n     *  @returns {HistoryDatasetAssociation} the model with the given hid or undefined if not found\n     */\n            getByHid: function(hid) {\n                // note: there *can* be more than one content with a given hid, this finds the first based on order\n                return this.findWhere({ hid: hid });\n            },\n\n            /** return true if all contents have details */\n            haveDetails: function() {\n                return this.all(function(c) {\n                    return c.hasDetails();\n                });\n            },\n\n            // ........................................................................ hidden / deleted\n            /** return a new contents collection of only hidden items */\n            hidden: function() {\n                return this.filter(function(c) {\n                    return c.hidden();\n                });\n            },\n\n            /** return a new contents collection of only hidden items */\n            deleted: function() {\n                return this.filter(function(c) {\n                    return c.get(\"deleted\");\n                });\n            },\n\n            /** return a new contents collection of only hidden items */\n            visibleAndUndeleted: function() {\n                return this.filter(function(c) {\n                    return (\n                        c.get(\"visible\") &&\n                        // TODO: deletedOrPurged?\n                        !c.get(\"deleted\")\n                    );\n                });\n            },\n\n            /** create a setter in order to publish the change */\n            setIncludeDeleted: function(setting, options) {\n                if (_.isBoolean(setting) && setting !== this.includeDeleted) {\n                    this.includeDeleted = setting;\n                    if (_.result(options, \"silent\")) {\n                        return;\n                    }\n                    this.trigger(\"include-deleted\", setting, this);\n                }\n            },\n\n            /** create a setter in order to publish the change */\n            setIncludeHidden: function(setting, options) {\n                if (_.isBoolean(setting) && setting !== this.includeHidden) {\n                    this.includeHidden = setting;\n                    options = options || {};\n                    if (_.result(options, \"silent\")) {\n                        return;\n                    }\n                    this.trigger(\"include-hidden\", setting, this);\n                }\n            },\n\n            // ........................................................................ ajax\n            // ............ controlled fetch collection\n            /** override to get expanded ids from sessionStorage and pass to API as details */\n            fetch: function(options) {\n                options = options || {};\n                if (this.historyId && !options.details) {\n                    var prefs = HISTORY_PREFS.HistoryPrefs.get(this.historyId).toJSON();\n                    if (!_.isEmpty(prefs.expandedIds)) {\n                        options.details = _.values(prefs.expandedIds).join(\",\");\n                    }\n                }\n                return _super.prototype.fetch.call(this, options);\n            },\n\n            // ............. ControlledFetch stuff\n            /** override to include the API versioning flag */\n            _buildFetchData: function(options) {\n                return _.extend(_super.prototype._buildFetchData.call(this, options), {\n                    v: \"dev\"\n                });\n            },\n\n            /** Extend to include details and version */\n            _fetchParams: _super.prototype._fetchParams.concat([\n                // TODO: remove (the need for) both\n                /** version */\n                \"v\",\n                /** dataset ids to get full details of */\n                \"details\"\n            ]),\n\n            /** override to add deleted/hidden filters */\n            _buildFetchFilters: function(options) {\n                var superFilters = _super.prototype._buildFetchFilters.call(this, options) || {};\n                var filters = {};\n                if (!this.includeDeleted) {\n                    filters.deleted = false;\n                    filters.purged = false;\n                }\n                if (!this.includeHidden) {\n                    filters.visible = true;\n                }\n                return _.defaults(superFilters, filters);\n            },\n\n            // ............ paginated collection\n            getTotalItemCount: function() {\n                return this.history.contentsShown();\n            },\n\n            // ............ history contents specific ajax\n            /** override to filter requested contents to those updated after the Date 'since' */\n            fetchUpdated: function(since, options) {\n                if (since) {\n                    options = options || { filters: {} };\n                    options.remove = false;\n                    options.filters = {\n                        \"update_time-ge\": since.toISOString(),\n                        // workflows will produce hidden datasets (non-output datasets) that still\n                        // need to be updated in the collection or they'll update forever\n                        // we can remove the default visible filter by using an 'empty' value\n                        visible: \"\"\n                    };\n                }\n                return this.fetch(options);\n            },\n\n            /** fetch all the deleted==true contents of this collection */\n            fetchDeleted: function(options) {\n                options = options || {};\n                var self = this;\n                options.filters = _.extend(options.filters, {\n                    // all deleted, purged or not\n                    deleted: true,\n                    purged: undefined\n                });\n                options.remove = false;\n\n                self.trigger(\"fetching-deleted\", self);\n                return self.fetch(options).always(function() {\n                    self.trigger(\"fetching-deleted-done\", self);\n                });\n            },\n\n            /** fetch all the visible==false contents of this collection */\n            fetchHidden: function(options) {\n                options = options || {};\n                var self = this;\n                options.filters = _.extend(options.filters, {\n                    visible: false\n                });\n                options.remove = false;\n\n                self.trigger(\"fetching-hidden\", self);\n                return self.fetch(options).always(function() {\n                    self.trigger(\"fetching-hidden-done\", self);\n                });\n            },\n\n            /** fetch detailed model data for all contents in this collection */\n            fetchAllDetails: function(options) {\n                options = options || {};\n                var detailsFlag = { details: \"all\" };\n                options.data = _.extend(options.data || {}, detailsFlag);\n                return this.fetch(options);\n            },\n\n            /** specialty fetch method for retrieving the element_counts of all hdcas in the history */\n            fetchCollectionCounts: function(options) {\n                options = options || {};\n                options.keys = [\"type_id\", \"element_count\"].join(\",\");\n                options.filters = _.extend(options.filters || {}, {\n                    history_content_type: \"dataset_collection\"\n                });\n                options.remove = false;\n                return this.fetch(options);\n            },\n\n            // ............. quasi-batch ops\n            // TODO: to batch\n            /** helper that fetches using filterParams then calls save on each fetched using updateWhat as the save params */\n            _filterAndUpdate: function(filterParams, updateWhat) {\n                var self = this;\n                var idAttribute = self.model.prototype.idAttribute;\n                var updateArgs = [updateWhat];\n\n                return self.fetch({ filters: filterParams, remove: false }).then(function(fetched) {\n                    // convert filtered json array to model array\n                    fetched = fetched.reduce(function(modelArray, currJson, i) {\n                        var model = self.get(currJson[idAttribute]);\n                        return model ? modelArray.concat(model) : modelArray;\n                    }, []);\n                    return self.ajaxQueue(\"save\", updateArgs, fetched);\n                });\n            },\n\n            /** using a queue, perform ajaxFn on each of the models in this collection */\n            ajaxQueue: function(ajaxFn, args, collection) {\n                collection = collection || this.models;\n                return new AJAX_QUEUE.AjaxQueue(\n                    collection\n                        .slice()\n                        .reverse()\n                        .map(function(content, i) {\n                            var fn = _.isString(ajaxFn) ? content[ajaxFn] : ajaxFn;\n                            return function() {\n                                return fn.apply(content, args);\n                            };\n                        })\n                ).deferred;\n            },\n\n            /** fetch contents' details in batches of limitPerCall - note: only get searchable details here */\n            progressivelyFetchDetails: function(options) {\n                options = options || {};\n                var deferred = jQuery.Deferred();\n                var self = this;\n                var limit = options.limitPerCall || self.limitPerProgressiveFetch;\n                // TODO: only fetch tags and annotations if specifically requested\n                var searchAttributes = HDA_MODEL.HistoryDatasetAssociation.prototype.searchAttributes;\n                var detailKeys = searchAttributes.join(\",\");\n\n                function _recursivelyFetch(offset) {\n                    offset = offset || 0;\n                    var _options = _.extend(_.clone(options), {\n                        view: \"summary\",\n                        keys: detailKeys,\n                        limit: limit,\n                        offset: offset,\n                        reset: offset === 0,\n                        remove: false\n                    });\n\n                    _.defer(function() {\n                        self.fetch\n                            .call(self, _options)\n                            .fail(deferred.reject)\n                            .done(function(response) {\n                                deferred.notify(response, limit, offset);\n                                if (response.length !== limit) {\n                                    self.allFetched = true;\n                                    deferred.resolve(response, limit, offset);\n                                } else {\n                                    _recursivelyFetch(offset + limit);\n                                }\n                            });\n                    });\n                }\n                _recursivelyFetch();\n                return deferred;\n            },\n\n            /** does some bit of JSON represent something that can be copied into this contents collection */\n            isCopyable: function(contentsJSON) {\n                var copyableModelClasses = [\"HistoryDatasetAssociation\", \"HistoryDatasetCollectionAssociation\"];\n                return (\n                    _.isObject(contentsJSON) &&\n                    contentsJSON.id &&\n                    _.contains(copyableModelClasses, contentsJSON.model_class)\n                );\n            },\n\n            /** copy an existing, accessible hda into this collection */\n            copy: function(json) {\n                // TODO: somehow showhorn all this into 'save'\n                var id, type, contentType;\n                if (_.isString(json)) {\n                    id = json;\n                    contentType = \"hda\";\n                    type = \"dataset\";\n                } else {\n                    id = json.id;\n                    contentType =\n                        {\n                            HistoryDatasetAssociation: \"hda\",\n                            LibraryDatasetDatasetAssociation: \"ldda\",\n                            HistoryDatasetCollectionAssociation: \"hdca\"\n                        }[json.model_class] || \"hda\";\n                    type = contentType === \"hdca\" ? \"dataset_collection\" : \"dataset\";\n                }\n                var collection = this,\n                    xhr = jQuery\n                        .ajax(this.url(), {\n                            method: \"POST\",\n                            contentType: \"application/json\",\n                            data: JSON.stringify({\n                                content: id,\n                                source: contentType,\n                                type: type\n                            })\n                        })\n                        .done(function(response) {\n                            collection.add([response], { parse: true });\n                        })\n                        .fail(function(error, status, message) {\n                            collection.trigger(\"error\", collection, xhr, {}, \"Error copying contents\", {\n                                type: type,\n                                id: id,\n                                source: contentType\n                            });\n                        });\n                return xhr;\n            },\n\n            /** create a new HDCA in this collection */\n            createHDCA: function(elementIdentifiers, collectionType, name, hideSourceItems, options) {\n                // normally collection.create returns the new model, but we need the promise from the ajax, so we fake create\n                //precondition: elementIdentifiers is an array of plain js objects\n                //  in the proper form to create the collectionType\n                var hdca = this.model({\n                    history_content_type: \"dataset_collection\",\n                    collection_type: collectionType,\n                    history_id: this.historyId,\n                    name: name,\n                    hide_source_items: hideSourceItems || false,\n                    // should probably be able to just send in a bunch of json here and restruct per class\n                    // note: element_identifiers is now (incorrectly) an attribute\n                    element_identifiers: elementIdentifiers\n                    // do not create the model on the client until the ajax returns\n                });\n                return hdca.save(options);\n            },\n\n            // ........................................................................ searching\n            /** return true if all contents have the searchable attributes */\n            haveSearchDetails: function() {\n                return (\n                    this.allFetched &&\n                    this.all(function(content) {\n                        // null (which is a valid returned annotation value)\n                        // will return false when using content.has( 'annotation' )\n                        //TODO: a bit hacky - formalize\n                        return _.has(content.attributes, \"annotation\");\n                    })\n                );\n            },\n\n            /** return a new collection of contents whose attributes contain the substring matchesWhat */\n            matches: function(matchesWhat) {\n                return this.filter(function(content) {\n                    return content.matches(matchesWhat);\n                });\n            },\n\n            // ........................................................................ misc\n            /** In this override, copy the historyId to the clone */\n            clone: function() {\n                var clone = Backbone.Collection.prototype.clone.call(this);\n                clone.historyId = this.historyId;\n                return clone;\n            },\n\n            /** String representation. */\n            toString: function() {\n                return [\"HistoryContents(\", [this.historyId, this.length].join(), \")\"].join(\"\");\n            }\n        });\n\n        //==============================================================================\n        return {\n            HistoryContents: HistoryContents\n        };\n    }\n);\n"]}