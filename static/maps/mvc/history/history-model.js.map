{"version":3,"sources":["mvc/history/history-model.js"],"names":["define","HISTORY_CONTENTS","HISTORY_PREFS","CONTROLLED_FETCH_COLLECTION","UTILS","BASE_MVC","_l","History","Backbone","Model","extend","LoggableMixin","mixin","defaults","SearchableModelMixin","_logNamespace","UPDATE_DELAY","contents_states","model_class","id","root","state","deleted","contents_active","searchAttributes","searchAliases","Galaxy","contentsClass","HistoryContents","title","tag","historyId","get","historyJSON","options","order","this","logger","log","contents","history","updateTimeoutId","_setUpListeners","_setUpCollectionListeners","on","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","listenTo","contentsActive","trigger","apply","jQuery","makeArray","arguments","contentsShown","active","size","bytesToString","shown","includeHidden","hidden","nice_size","key","prototype","toJSON","call","ownedByCurrUser","user","unfinishedJobIds","numOfUnfinishedJobs","length","data","keys","contentRelatedAttrs","_fetchContentRelatedAttributes","$","param","join","allFetched","self","lastUpdateTime","checkForUpdates","serverResponseDatetime","getResponseHeader","Date","currentPage","fetchUpdated","done","status","err","nonReadyContentCount","setTimeout","refresh","delay","_delayThenUpdate","historyData","parsed","create_time","clearTimeout","update_time","parse","response","fetchWithContents","contentsOptions","setHistoryId","fetchContents","view","fetch","then","fetchCurrentPage","_delete","when","save","purge","purged","undelete","postData","name","allDatasets","current","undefined","all_datasets","Error","history_id","newHistory","copy","setAsCurrent","getJSON","HistoryCollection","_collectionSuper","InfinitelyScrollingCollection","models","limitOnFirstFetch","currentHistoryId","limitPerFetch","setUpListeners","initialize","urlRoot","includeDeleted","url","change:deleted","oldCurrentId","remove","_buildFetchData","original","newData","set-as-current","_buildFetchFilters","_","superFilters","filters","limit","fetchFirst","ascending","offset","fetchMore","buildComparator","comparators","clone","silent","unshift","currentHistory","size-asc","create","collection","setCurrent","historyOptions","xhrOptions","toString"],"mappings":"aAAAA,QAEQ,+BAQA,kCANA,uCAQA,cACA,eANA,sBAEJ,SAASC,EAAkBC,EAAeC,EAA6BC,EAAOC,EAAUC,GASpF,IAAIC,EAAUC,SAASC,MAAMC,OAAOL,EAASM,eAAeD,OAShDL,EAAAO,MACAC,EAAUC,sBAAAC,cAAA,UAHVC,aAAc,IAWVC,UAfwBC,YAAA,UASxBC,GAAI,KASQC,KAAP,kBAPLC,MAAO,MAEPC,SAAS,EASbC,mBACAC,oBAGAC,QAAeC,OAAAN,KAAA,gBAENO,cAAA1B,EAAA2B,gBAGTJ,kBAAA,OAAA,aAAA,QALAC,eACII,MAAO,OASCC,IAAA,QAQJC,WAAgBC,SAFuBC,EAAAC,GAGhCA,EAAQC,MAHnBC,KAAAC,OAAAH,EAAAG,QAAA,KAHAD,KAAKE,IAAIF,KAAO,eAAgBH,EAAaC,GAG7CE,KAAKG,SAAW,IAAIH,KAAKT,kBASzBa,QAAAJ,KACKK,UAALL,KAAAJ,IAAA,MApDwBG,MAAAD,EAAAC,QAgDxBC,KAAKM,kBACLN,KAAKO,4BAWOC,KAAGH,gBAAA,MAMHC,gBAAA,WAEP,OAAAN,KAAAQ,IARLC,MAAA,SAAAC,EAAAC,EAAAb,EAAAc,EAAAC,GA5DwBb,KAAAc,sBAwE5BC,YAAA,SAAAL,EAAAM,GAC2BhB,KAAAG,WACHH,KAAAG,SAAAR,UAAAqB,OAOfT,0BAAA,WAHL,OAAAP,KAAAG,SAQJH,KAAAiB,SAAAjB,KAAAG,UACeM,MAAA,WACPS,KAAiBC,QAASC,MAAApB,KAAAqB,OAA9BC,UAAAC,eAxFwBvB,MA+F5BwB,cAAA,WACW,IAAAN,EAAWlB,KAAAJ,IAAA,mBACFA,EAAIsB,EAApBO,QAAA,EALA,OAMOC,GAAaC,KAAAA,SAAcD,eAAiBxD,EAAnDgB,QAAA,EAlGwB0C,GAAA5B,KAAAG,SAAA0B,cAAAX,EAAAY,OAAA,GAwGpBC,UAAW,WADf,IAAAL,EAAA1B,KAAAJ,IAAA,QAvGwB,OAAA8B,EAAA1D,EAAA2D,cAAAD,GAAA,EAAA,GAAAxD,EAAA,YA8GpB8D,OAAQ,WACD,OAAKD,EAAAA,OAAZ3D,SAAAC,MAAA4D,UAAAC,OAAAC,KAAAnC,OACH+B,UAAA/B,KAAA+B,eAKLnC,IAAA,SAAAoC,GAPI,MAAY,cAARA,EACOhC,KAAK+B,YAUhB3D,SAAAC,MAAA4D,UAAArC,IAAAwB,MAAApB,KAAAuB,YAOCa,gBAAA,WAhIuB,SAAA9C,SAAAA,OAAA+C,SAsIpBC,OAAmBD,KAAKzC,eAAIN,OAAhC+C,KAAAtD,KAAAiB,KAAAJ,IAAA,aAtIwB2C,oBAAA,WAsIxB,IAAID,EAAmBtC,KAAKJ,IAAI,kBASpC,OAAA0C,EAAAA,EAAAE,OAAA,GAIQC,6BAAc,WACVC,OAAMC,KAAAA,SAAAA,mBAAAH,QAAA,GAJlBI,+BAAgC,WAShC,IAAAD,GAAA,OAAA,iBAAA,kBAAA,eACS,OAAA3C,KAASF,OACd2C,KAAAI,EAAAC,OACUhD,KAAV6C,EAAAI,KAAA,UAMK5C,QAAS6C,SAAdlD,GAIqBmD,EAAK9C,MAEhB,IAAW8C,EAAAjD,KAGrBkD,EAAAD,EAAAC,eAYJC,OAVYC,KAAAA,SAAAA,YAAJ,GAE0CC,IAAtCD,EAAAA,SAAAA,YACY,WACMA,OAAAA,EAAAA,SAAAA,UAA8BE,EAApDnD,SAAAoD,cALJ,WA5KwB,OAAAN,EAAA9C,SAAAqD,aAAAN,OAuLXO,KAAA,SAAS3D,EAAS4D,EAAA/C,GAC/B,IAAAyC,EACUtD,IACOlB,EAAjB,IAAA0E,KAAA3C,EAAA0C,kBAAA,SACA,MAAAM,IACcV,EAAAC,eAAAE,GAAA,IAAAE,KACVL,EAAAE,gBAAArD,MAKAmD,gBAAKnC,SAALhB,GASA8D,SAAAA,IAEGX,EAAAnC,qBACHmC,EAAA5C,gBAAAwD,WAAA,WACAZ,EAAAa,QAAAhE,IACAiE,GAZId,EAAanD,MADM,IAAvBiE,EAAA/D,KAAApB,aAGHqE,EAAAjD,KAVIiD,EAAKlE,KAwBEiF,KAAAA,+BAEA,EACAf,IANRA,EAAKL,iCAAiCa,KAAK,SAASQ,GAaxChB,EAAAV,sBAAW,EAC3ByB,IAGCf,EAAA9B,QAAA,aAOG+C,mBAAoB,WACbC,KAAAA,kBACVC,aAAApE,KAAAK,iBACUgE,KAAAA,gBAAa,OAM5BC,MAAA,SAAAC,EAAAzE,GACA0E,IAAmBN,EAAA9F,SAAAC,MAAA4D,UAAAqC,MAAkBG,KAAAA,KAAlBF,EAAmCzE,GAJlD,OAKUA,EAAVqE,cACAD,EAAAC,YAAA,IAAAb,KAAAY,EAAAC,cAEAD,EAAAG,cACAH,EAAAG,YAAA,IAAAf,KAAAY,EAAAG,cATOH,GAeHjB,kBAAcyB,SAAatE,EAA3BqE,GAFJ,IAAAxB,EAAAjD,KAAA,OAGWiD,EAAK0B,OAKLC,KAAA,eARJ5E,KAAK6E,MAAM/E,GAASgF,KAAK,SAAqB1E,GAczCD,OAFZ8C,EAAA9C,SAAAC,QAAA6C,EACKC,EAAL/C,SAAsBuE,aAAtBtE,EAAArB,IACqBgG,EAAAA,cAAiBjF,MAKlC6E,cAAJ,SAAyB7E,GACduB,EAAAvB,MACV,IAAAmD,EAAAjD,KAIE,OADPiD,EAAAC,eAAA,IAAAI,KACgBxD,EAAAA,SAASiF,iBAAAjF,IAIdkF,QAAU,SAAE9F,GAzRK,OAAAc,KAAAJ,IAAA,WA2R5ByB,OAAA4D,OAEkBjF,KAAdkF,MAA0BhG,SAAA,GAAAY,IAGnBqF,MAAKD,SAAOhG,GAhSK,OAAAc,KAAAJ,IAAA,UAuRbyB,OAAO4D,OAEXjF,KAAKkF,MAAOhG,SAAS,EAAMkG,QAAQ,GAAQtF,IAGtDuF,SAAU,SAASvF,GACf,OAAKE,KAAKJ,IAAI,WAcAI,KAAAkF,MAAAhG,SAAA,GAAAY,GAFZuB,OAAA4D,QAWEK,KAASC,SAAOA,EAAhBA,EAAAC,GAECA,GADJC,OAAAC,IAAAD,GAAAA,GACDzF,KAAkBjB,GACL4G,MAAAA,IAATC,MAAwB,kDAR5B,IAAIN,GAAaO,WAAY7F,KAAKjB,IAYpB0G,IACHpE,EAAYoE,SAAZ,GAEEF,IACGT,EAAKS,KAAShB,GAEfuB,IACH1F,EAAQe,cAAkBf,GAHlCkF,EAAAV,KAAA,eAOQnB,IAALrD,EAAUJ,KACLmB,EAAQE,OAAUjB,KAAAA,KAASmE,QAAnCe,GAvUoB,OAAAG,EA+TbM,EAAKjB,KAAK,SAASP,GAa9B,OADqB,IAAApG,EAAAoG,GACrByB,eAAAvC,KAAA,WACUrD,EAAsBpB,QAAO,SAAAoB,EAAAmE,OAEvCwB,EAAAtC,KAAA,SAAAc,GAGAnE,EAAAe,QAAA,SAAAf,EAAAmE,MAIMyB,aAAA,WACC,IAAA5F,EAAkBR,KAC5Be,EAAAU,OAAA4E,QAAA3G,OAAAN,KAAA,6BAAAgB,KAAAjB,IAOb,OAhBgB4B,EAAI8C,KAAK,WAczBrD,EAAAe,QAAA,iBAAAf,KAEAO,GAIIuF,SAAoBC,WACL,MAAA,WAD4DnG,KAAAJ,IAAA,MAAA,IAAAI,KAAAJ,IAAA,QAAA,QAQ3EuG,EAAApI,EAAAqI,8BAKIF,EAASC,EAAA7H,OAAgC+H,EAAQvG,eAAjDxB,QACA6H,cAAAA,UAEAzF,MAAAvC,EAXJ4B,MAAO,cAeHuG,kBAAKC,GAELC,cAAKC,GAELC,WAAA,SAAAL,EAAAvG,GAxBuEA,EAAAA,MAavEE,KAAKE,IAAI,+BAAgCmG,EAAQvG,GAcrD6G,EAAuB1E,UAAAyE,WA3BoDvE,KAAAnC,KAAAqG,EAAAvG,GAAAE,KAAA4G,eAAA9G,EAAA8G,iBAAA,EAiC3EH,KAAAA,iBAAyBA,EAATF,iBAERvG,KAAAyG,kBAKQE,QAAArH,OAAAN,KAAA,gBACH6H,IAAA,WACJ,OARU7G,KAAA2G,SAYVF,eAZU,WAaX,OAAAzG,KAAAQ,IAEIsG,iBAAIC,SAAoBR,GAExBvG,KAAKuG,MAAAA,iBAA2BxH,KAAhC6H,eAAAxG,EAAAR,IAAA,aACHI,KAAA4G,gBAAAxG,EAAAR,IAAA,YAlBLI,KAAAgH,OAAA5G,IAuBJ6G,OAAiB,SAAAC,EAAAC,GACJ7I,KAAO6H,WAAAA,IAAAA,EAAiBlE,QA1DsCmF,iBAAA,SAAAhH,GAiD/D,IAAI2G,EAAe/G,KAAKuG,iBAcpCvG,KAAAmB,QAAA,oBAAA4F,GACAM,KAAoBd,iBAAAnG,EAASN,OAMxBmH,gBAAM,SAAAnH,GACH,OAAAwH,EAAAhJ,OAAA6H,EAAAlE,UAAAgF,gBAAA9E,KAAAnC,KAAAF,IACA8E,KAAA,kBARRyC,mBAAoB,SAASvH,GAc7B,IAAAyH,EAAApB,EAAAlE,UAAAoF,mBAAAlF,KAAAnC,KAAAF,OACY0H,KASI,OARRvE,KAAO2D,eAMHa,EAFmDvI,QAAA,MAH3DsI,EAAAtI,SAAA,EACIyB,EAAMyE,QAAV,GAMYkC,EAAA7I,SAAA8I,EAAAC,IADKE,WAAA,SAAA5H,GAH0C,IAAvDmD,EAAAjD,KAWGW,EAAImE,EAAKG,OAaZ0C,OAZA7H,KAAAA,mBACAA,EAAQ8H,EAAR3F,UAAAyF,WAAAvF,KAAAc,GACOA,QAAK4E,EAHhBJ,MAAA,EA/FuED,SAsG3EpC,OAAA,GACe9G,QAAO,GACHwJ,gBAAgB9H,KAAzBuG,qBAIFoB,EAAW7C,KAAA,WAGX6C,OAR+D7H,EAAAA,MAO7D7B,EAAS6J,OAAAA,EACA7E,EAAA4E,UAAA/H,MA/GwDiI,YAAAT,EAAAhJ,OAAAgJ,EAAAU,MAAA7B,EAAAlE,UAAA8F,cAwGvExC,KAAMtH,EAAS6J,gBAAgB,QAcnCH,WAAA,IAEI7H,WAAUA,EAAVgI,gBAAA,QACIG,WAASnI,IAEbqG,KAAAA,EAAiBlE,gBAAeE,QAC3B+F,WAAQC,IAETC,WAAAnK,EAAqB6J,gBAArB,QACHH,WAAA,MAKLU,KAAQ,SAASA,GAETC,IAAAA,GADJxI,EAAAA,OACAmI,OACItH,EAAqBrB,KAAAA,OAAAU,KAAcJ,IAAAI,KAAAuG,mBAM3C,OALIJ,EAAgBlE,UAASkF,KAAShF,KAAAnC,KAAAsH,EAAA7I,UAAAwJ,QAAA,GAAAnI,IAC9BwI,KAAAA,QAAWC,GAAepK,QAAQgJ,IADtCc,GAxIuEjI,KAAAmB,QAAA,OAAAnB,KAAAF,GA6I3EE,MAIAuI,OAAY,SAAA9F,EAASrC,EAAToI,EAA2BC,GAEnC,IAAAH,EAAAtI,KAEA,OADaI,OAAb6F,QAAA3G,OAAAN,KAAA,8BACKuH,KAAAA,SAAmBnG,GACnBN,EAALyI,WAAqB,IAAApK,EAAAgJ,KAAAqB,WAQxBD,WAAA,SAAAnI,EAAAN,GAthBb,OAwXQA,EAAAA,MAiKAE,KAAAkI,QAAA9H,EAAAN,GACOE,KAAAuG,iBAAAnG,EAAAR,IAAA,MACMzB,EADN8J,QAEH/B,KAAAA,QAAmBA,cAAAA,EAAAA,MA5hB/BlG,MAohBY0I,SAAU,WACN,MAAO,qBAAuB1I,KAAKwC,OAAS,YAAcxC,KAAKuG,iBAAmB,OAK1F,OACIpI,QAASA,EACT+H,kBAAmBA","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["define(\n    [\n        \"mvc/history/history-contents\",\n        \"mvc/history/history-preferences\",\n        \"mvc/base/controlled-fetch-collection\",\n        \"utils/utils\",\n        \"mvc/base-mvc\",\n        \"utils/localization\"\n    ],\n    function(HISTORY_CONTENTS, HISTORY_PREFS, CONTROLLED_FETCH_COLLECTION, UTILS, BASE_MVC, _l) {\n        \"use strict\";\n\n        //==============================================================================\n        /** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\n        var History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n            BASE_MVC.mixin(\n                BASE_MVC.SearchableModelMixin,\n                /** @lends History.prototype */ {\n                    _logNamespace: \"history\",\n\n                    /** ms between fetches when checking running jobs/datasets for updates */\n                    UPDATE_DELAY: 4000,\n\n                    // values from api (may need more)\n                    defaults: {\n                        model_class: \"History\",\n                        id: null,\n                        name: \"Unnamed History\",\n                        state: \"new\",\n\n                        deleted: false,\n                        contents_active: {},\n                        contents_states: {}\n                    },\n\n                    urlRoot: Galaxy.root + \"api/histories\",\n\n                    contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n                    /** What model fields to search with */\n                    searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n                    /** Adding title and singular tag */\n                    searchAliases: {\n                        title: \"name\",\n                        tag: \"tags\"\n                    },\n\n                    // ........................................................................ set up/tear down\n                    /** Set up the model\n     *  @param {Object} historyJSON model data for this History\n     *  @param {Object} options     any extra settings including logger\n     */\n                    initialize: function(historyJSON, options) {\n                        options = options || {};\n                        this.logger = options.logger || null;\n                        this.log(this + \".initialize:\", historyJSON, options);\n\n                        /** HistoryContents collection of the HDAs contained in this history. */\n                        this.contents = new this.contentsClass([], {\n                            history: this,\n                            historyId: this.get(\"id\"),\n                            order: options.order\n                        });\n\n                        this._setUpListeners();\n                        this._setUpCollectionListeners();\n\n                        /** cached timeout id for the dataset updater */\n                        this.updateTimeoutId = null;\n                    },\n\n                    /** set up any event listeners for this history including those to the contained HDAs\n     *  events: error:contents  if an error occurred with the contents collection\n     */\n                    _setUpListeners: function() {\n                        // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                        return this.on({\n                            error: function(model, xhr, options, msg, details) {\n                                this.clearUpdateTimeout();\n                            },\n                            \"change:id\": function(model, newId) {\n                                if (this.contents) {\n                                    this.contents.historyId = newId;\n                                }\n                            }\n                        });\n                    },\n\n                    /** event handlers for the contents submodels */\n                    _setUpCollectionListeners: function() {\n                        if (!this.contents) {\n                            return this;\n                        }\n                        // bubble up errors\n                        return this.listenTo(this.contents, {\n                            error: function() {\n                                this.trigger.apply(this, jQuery.makeArray(arguments));\n                            }\n                        });\n                    },\n\n                    // ........................................................................ derived attributes\n                    /**  */\n                    contentsShown: function() {\n                        var contentsActive = this.get(\"contents_active\");\n                        var shown = contentsActive.active || 0;\n                        shown += this.contents.includeDeleted ? contentsActive.deleted : 0;\n                        shown += this.contents.includeHidden ? contentsActive.hidden : 0;\n                        return shown;\n                    },\n\n                    /** convert size in bytes to a more human readable version */\n                    nice_size: function() {\n                        var size = this.get(\"size\");\n                        return size ? UTILS.bytesToString(size, true, 2) : _l(\"(empty)\");\n                    },\n\n                    /** override to add nice_size */\n                    toJSON: function() {\n                        return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                            nice_size: this.nice_size()\n                        });\n                    },\n\n                    /** override to allow getting nice_size */\n                    get: function(key) {\n                        if (key === \"nice_size\") {\n                            return this.nice_size();\n                        }\n                        return Backbone.Model.prototype.get.apply(this, arguments);\n                    },\n\n                    // ........................................................................ common queries\n                    /** T/F is this history owned by the current user (Galaxy.user)\n     *      Note: that this will return false for an anon user even if the history is theirs.\n     */\n                    ownedByCurrUser: function() {\n                        // no currUser\n                        if (!Galaxy || !Galaxy.user) {\n                            return false;\n                        }\n                        // user is anon or history isn't owned\n                        if (Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get(\"user_id\")) {\n                            return false;\n                        }\n                        return true;\n                    },\n\n                    /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n                    numOfUnfinishedJobs: function() {\n                        var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                        return unfinishedJobIds ? unfinishedJobIds.length : 0;\n                    },\n\n                    /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n                    numOfUnfinishedShownContents: function() {\n                        return this.contents.runningAndActive().length || 0;\n                    },\n\n                    // ........................................................................ updates\n                    _fetchContentRelatedAttributes: function() {\n                        var contentRelatedAttrs = [\"size\", \"non_ready_jobs\", \"contents_active\", \"hid_counter\"];\n                        return this.fetch({\n                            data: $.param({\n                                keys: contentRelatedAttrs.join(\",\")\n                            })\n                        });\n                    },\n\n                    /** check for any changes since the last time we updated (or fetch all if ) */\n                    refresh: function(options) {\n                        // console.log( this + '.refresh' );\n                        options = options || {};\n                        var self = this;\n\n                        // note if there was no previous update time, all summary contents will be fetched\n                        var lastUpdateTime = self.lastUpdateTime;\n                        // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                        this.contents.allFetched = false;\n                        var fetchFn =\n                            self.contents.currentPage !== 0\n                                ? function() {\n                                      return self.contents.fetchPage(self.contents.currentPage);\n                                  }\n                                : function() {\n                                      return self.contents.fetchUpdated(lastUpdateTime);\n                                  };\n                        // note: if there was no previous update time, all summary contents will be fetched\n                        return fetchFn().done(function(response, status, xhr) {\n                            var serverResponseDatetime;\n                            try {\n                                serverResponseDatetime = new Date(xhr.getResponseHeader(\"Date\"));\n                            } catch (err) {}\n                            self.lastUpdateTime = serverResponseDatetime || new Date();\n                            self.checkForUpdates(options);\n                        });\n                    },\n\n                    /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n                    checkForUpdates: function(options) {\n                        // console.log( this + '.checkForUpdates' );\n                        options = options || {};\n                        var delay = this.UPDATE_DELAY;\n                        var self = this;\n                        if (!self.id) {\n                            return;\n                        }\n\n                        function _delayThenUpdate() {\n                            // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                            self.clearUpdateTimeout();\n                            self.updateTimeoutId = setTimeout(function() {\n                                self.refresh(options);\n                            }, delay);\n                        }\n\n                        // if there are still datasets in the non-ready state, recurse into this function with the new time\n                        var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                        // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                        if (nonReadyContentCount > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // no datasets are running, but currently runnning jobs may still produce new datasets\n                            // see if the history has any running jobs and continue to update if so\n                            // (also update the size for the user in either case)\n                            self._fetchContentRelatedAttributes().done(function(historyData) {\n                                // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                                if (self.numOfUnfinishedJobs() > 0) {\n                                    _delayThenUpdate();\n                                } else {\n                                    // otherwise, let listeners know that all updates have stopped\n                                    self.trigger(\"ready\");\n                                }\n                            });\n                        }\n                    },\n\n                    /** clear the timeout and the cached timeout id */\n                    clearUpdateTimeout: function() {\n                        if (this.updateTimeoutId) {\n                            clearTimeout(this.updateTimeoutId);\n                            this.updateTimeoutId = null;\n                        }\n                    },\n\n                    // ........................................................................ ajax\n                    /** override to use actual Dates objects for create/update times */\n                    parse: function(response, options) {\n                        var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                        if (parsed.create_time) {\n                            parsed.create_time = new Date(parsed.create_time);\n                        }\n                        if (parsed.update_time) {\n                            parsed.update_time = new Date(parsed.update_time);\n                        }\n                        return parsed;\n                    },\n\n                    /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n                    fetchWithContents: function(options, contentsOptions) {\n                        options = options || {};\n                        var self = this;\n\n                        // console.log( this + '.fetchWithContents' );\n                        // TODO: push down to a base class\n                        options.view = \"dev-detailed\";\n\n                        // fetch history then use history data to fetch (paginated) contents\n                        return this.fetch(options).then(function getContents(history) {\n                            self.contents.history = self;\n                            self.contents.setHistoryId(history.id);\n                            return self.fetchContents(contentsOptions);\n                        });\n                    },\n\n                    /** fetch this histories contents, adjusting options based on the stored history preferences */\n                    fetchContents: function(options) {\n                        options = options || {};\n                        var self = this;\n\n                        // we're updating, reset the update time\n                        self.lastUpdateTime = new Date();\n                        return self.contents.fetchCurrentPage(options);\n                    },\n\n                    /** save this history, _Mark_ing it as deleted (just a flag) */\n                    _delete: function(options) {\n                        if (this.get(\"deleted\")) {\n                            return jQuery.when();\n                        }\n                        return this.save({ deleted: true }, options);\n                    },\n                    /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n                    purge: function(options) {\n                        if (this.get(\"purged\")) {\n                            return jQuery.when();\n                        }\n                        return this.save({ deleted: true, purged: true }, options);\n                    },\n                    /** save this history, _Mark_ing it as undeleted */\n                    undelete: function(options) {\n                        if (!this.get(\"deleted\")) {\n                            return jQuery.when();\n                        }\n                        return this.save({ deleted: false }, options);\n                    },\n\n                    /** Make a copy of this history on the server\n     *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n     *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n     *  @fires copied               passed this history and the response JSON from the copy\n     *  @returns {xhr}\n     */\n                    copy: function(current, name, allDatasets) {\n                        current = current !== undefined ? current : true;\n                        if (!this.id) {\n                            throw new Error(\"You must set the history ID before copying it.\");\n                        }\n\n                        var postData = { history_id: this.id };\n                        if (current) {\n                            postData.current = true;\n                        }\n                        if (name) {\n                            postData.name = name;\n                        }\n                        if (!allDatasets) {\n                            postData.all_datasets = false;\n                        }\n                        postData.view = \"dev-detailed\";\n\n                        var history = this;\n                        var copy = jQuery.post(this.urlRoot, postData);\n                        // if current - queue to setAsCurrent before firing 'copied'\n                        if (current) {\n                            return copy.then(function(response) {\n                                var newHistory = new History(response);\n                                return newHistory.setAsCurrent().done(function() {\n                                    history.trigger(\"copied\", history, response);\n                                });\n                            });\n                        }\n                        return copy.done(function(response) {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    },\n\n                    setAsCurrent: function() {\n                        var history = this,\n                            xhr = jQuery.getJSON(Galaxy.root + \"history/set_as_current?id=\" + this.id);\n\n                        xhr.done(function() {\n                            history.trigger(\"set-as-current\", history);\n                        });\n                        return xhr;\n                    },\n\n                    // ........................................................................ misc\n                    toString: function() {\n                        return \"History(\" + this.get(\"id\") + \",\" + this.get(\"name\") + \")\";\n                    }\n                }\n            )\n        );\n\n        //==============================================================================\n        var _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n        /** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\n        var HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n            _logNamespace: \"history\",\n\n            model: History,\n            /** @type {String} initial order used by collection */\n            order: \"update_time\",\n            /** @type {Number} limit used for the first fetch (or a reset) */\n            limitOnFirstFetch: 10,\n            /** @type {Number} limit used for each subsequent fetch */\n            limitPerFetch: 10,\n\n            initialize: function(models, options) {\n                options = options || {};\n                this.log(\"HistoryCollection.initialize\", models, options);\n                _collectionSuper.prototype.initialize.call(this, models, options);\n\n                /** @type {boolean} should deleted histories be included */\n                this.includeDeleted = options.includeDeleted || false;\n\n                /** @type {String} encoded id of the history that's current */\n                this.currentHistoryId = options.currentHistoryId;\n\n                this.setUpListeners();\n                // note: models are sent to reset *after* this fn ends; up to this point\n                // the collection *is empty*\n            },\n\n            urlRoot: Galaxy.root + \"api/histories\",\n            url: function() {\n                return this.urlRoot;\n            },\n\n            /** set up reflexive event handlers */\n            setUpListeners: function setUpListeners() {\n                return this.on({\n                    // when a history is deleted, remove it from the collection (if optionally set to do so)\n                    \"change:deleted\": function(history) {\n                        // TODO: this becomes complicated when more filters are used\n                        this.debug(\"change:deleted\", this.includeDeleted, history.get(\"deleted\"));\n                        if (!this.includeDeleted && history.get(\"deleted\")) {\n                            this.remove(history);\n                        }\n                    },\n                    // listen for a history copy, setting it to current\n                    copied: function(original, newData) {\n                        this.setCurrent(new History(newData, []));\n                    },\n                    // when a history is made current, track the id in the collection\n                    \"set-as-current\": function(history) {\n                        var oldCurrentId = this.currentHistoryId;\n                        this.trigger(\"no-longer-current\", oldCurrentId);\n                        this.currentHistoryId = history.id;\n                    }\n                });\n            },\n\n            /** override to change view */\n            _buildFetchData: function(options) {\n                return _.extend(_collectionSuper.prototype._buildFetchData.call(this, options), {\n                    view: \"dev-detailed\"\n                });\n            },\n\n            /** override to filter out deleted and purged */\n            _buildFetchFilters: function(options) {\n                var superFilters = _collectionSuper.prototype._buildFetchFilters.call(this, options) || {};\n                var filters = {};\n                if (!this.includeDeleted) {\n                    filters.deleted = false;\n                    filters.purged = false;\n                } else {\n                    // force API to return both deleted and non\n                    //TODO: when the API is updated, remove this\n                    filters.deleted = null;\n                }\n                return _.defaults(superFilters, filters);\n            },\n\n            /** override to fetch current as well (as it may be outside the first 10, etc.) */\n            fetchFirst: function(options) {\n                var self = this;\n                // TODO: batch?\n                var xhr = $.when();\n                if (this.currentHistoryId) {\n                    xhr = _collectionSuper.prototype.fetchFirst.call(self, {\n                        silent: true,\n                        limit: 1,\n                        filters: {\n                            // without these a deleted current history will return [] here and block the other xhr\n                            purged: \"\",\n                            deleted: \"\",\n                            \"encoded_id-in\": this.currentHistoryId\n                        }\n                    });\n                }\n                return xhr.then(function() {\n                    options = options || {};\n                    options.offset = 0;\n                    return self.fetchMore(options);\n                });\n            },\n\n            /** @type {Object} map of collection available sorting orders containing comparator fns */\n            comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n                name: BASE_MVC.buildComparator(\"name\", {\n                    ascending: true\n                }),\n                \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n                    ascending: false\n                }),\n                size: BASE_MVC.buildComparator(\"size\", {\n                    ascending: false\n                }),\n                \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n                    ascending: true\n                })\n            }),\n\n            /** override to always have the current history first */\n            sort: function(options) {\n                options = options || {};\n                var silent = options.silent;\n                var currentHistory = this.remove(this.get(this.currentHistoryId));\n                _collectionSuper.prototype.sort.call(this, _.defaults({ silent: true }, options));\n                this.unshift(currentHistory, { silent: true });\n                if (!silent) {\n                    this.trigger(\"sort\", this, options);\n                }\n                return this;\n            },\n\n            /** create a new history and by default set it to be the current history */\n            create: function create(data, hdas, historyOptions, xhrOptions) {\n                //TODO: .create is actually a collection function that's overridden here\n                var collection = this,\n                    xhr = jQuery.getJSON(Galaxy.root + \"history/create_new_current\");\n                return xhr.done(function(newData) {\n                    collection.setCurrent(new History(newData, [], historyOptions || {}));\n                });\n            },\n\n            /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n            setCurrent: function(history, options) {\n                options = options || {};\n                // new histories go in the front\n                this.unshift(history, options);\n                this.currentHistoryId = history.get(\"id\");\n                if (!options.silent) {\n                    this.trigger(\"new-current\", history, this);\n                }\n                return this;\n            },\n\n            toString: function toString() {\n                return \"HistoryCollection(\" + this.length + \",current:\" + this.currentHistoryId + \")\";\n            }\n        });\n\n        //==============================================================================\n        return {\n            History: History,\n            HistoryCollection: HistoryCollection\n        };\n    }\n);\n"]}