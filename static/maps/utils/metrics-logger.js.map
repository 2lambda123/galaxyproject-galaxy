{"version":3,"sources":["utils/metrics-logger.js"],"names":["define","MetricsLogger","options","self","this","window","bootstrapped","user","id","userId","_init","consoleLogger","LoggingCache","ALL","LOG","DEBUG","METRIC","NONE","logLevel","consoleLevel","defaultNamespace","consoleNamespaceWhitelist","clientPrefix","postSize","addTime","cacheKeyPrefix","delayPostInMs","onServerResponse","undefined","prototype","defaultOptions","hasOwnProperty","k","_parseLevel","_sending","_waiting","_postSize","_initCache","cache","maxCacheSize","key","maxSize","level","type","_typeof","upper","toUpperCase","Error","emit","namespace","logArguments","_addToCache","_emitToConsole","length","_postCache","add","_buildEntry","entry","arguments","args","time","Date","toISOString","when","postUrl","jQuery","count","entries","get","entriesLength","postData","JSON","stringify","getPingData","post","always","fail","xhr","status","message","readyState","done","response","_delayPost","remove","whitelist","setTimeout","unshift","indexOf","debug","apply","info","ERROR","error","WARN","warn","log","INFO","Array","slice","call","metric","_hasStorage","localStorage","setItem","_initStorage","getItem","removeItem","_cache","_unparseAndStore","_fetchAndParse","overage","parse","removed","splice","empty","print","console"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["define([], function() {\n    /*global window, jQuery, console */\n    /*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n    /** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\n    function MetricsLogger(options) {\n        options = options || {};\n        var self = this;\n\n        ///** get the current user's id from bootstrapped data or options */\n        self.userId = window.bootstrapped && window.bootstrapped.user ? window.bootstrapped.user.id : null;\n        self.userId = self.userId || options.userId || null;\n\n        /** the (optional) console to emit logs to */\n        self.consoleLogger = options.consoleLogger || null;\n\n        self._init(options);\n        return self;\n    }\n\n    //----------------------------------------------------------------------------- defaults and constants\n    // see: python std lib, logging\n    MetricsLogger.ALL = 0;\n    MetricsLogger.LOG = 0;\n    MetricsLogger.DEBUG = 10;\n    MetricsLogger.INFO = 20;\n    MetricsLogger.WARN = 30;\n    MetricsLogger.ERROR = 40;\n    // metrics levels here?\n    //MetricsLogger.MinorEvent  = 45;\n    //MetricsLogger.MajorEvent  = 50;\n    MetricsLogger.METRIC = 50;\n    MetricsLogger.NONE = 100;\n\n    /** default options - override these through the constructor */\n    MetricsLogger.defaultOptions = {\n        /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n        logLevel: MetricsLogger.NONE,\n        /** if an incoming message has a level >= this, it will be output to the console */\n        consoleLevel: MetricsLogger.NONE,\n        /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n        defaultNamespace: \"Galaxy\",\n        /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n        consoleNamespaceWhitelist: null,\n        /** the prefix attached to client-side logs to distinguish them in the metrics db */\n        clientPrefix: \"client.\",\n\n        /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n        maxCacheSize: 3000,\n        /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n        postSize: 1000,\n        /** T/F whether to add a timestamp to incoming cached messages */\n        addTime: true,\n        /** string to prefix to userid for cache web storage */\n        cacheKeyPrefix: \"logs-\",\n\n        /** the relative url to post messages to */\n        postUrl: \"/api/metrics\",\n        /** delay before trying post again after two failures */\n        delayPostInMs: 1000 * 60 * 10,\n\n        /** an (optional) function that should return an object; used to send additional data with the metrics */\n        getPingData: undefined,\n        /** an (optional) function that will handle the servers response after successfully posting messages */\n        onServerResponse: undefined\n    };\n\n    //----------------------------------------------------------------------------- set up\n    /** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\n    MetricsLogger.prototype._init = function _init(options) {\n        var self = this;\n        self.options = {};\n        for (var k in MetricsLogger.defaultOptions) {\n            if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n                self.options[k] = options.hasOwnProperty(k) ? options[k] : MetricsLogger.defaultOptions[k];\n            }\n        }\n        self.options.logLevel = self._parseLevel(self.options.logLevel);\n        self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n        //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n        /** is the logger currently sending? */\n        self._sending = false;\n        /** the setTimeout id if the logger POST has failed more than once */\n        self._waiting = null;\n        /** the current number of entries to send in a POST */\n        self._postSize = self.options.postSize;\n\n        self._initCache();\n\n        return self;\n    };\n\n    /** initialize the cache */\n    MetricsLogger.prototype._initCache = function _initCache() {\n        try {\n            this.cache = new LoggingCache({\n                maxSize: this.options.maxCacheSize,\n                key: this.options.cacheKeyPrefix + this.userId\n            });\n        } catch (err) {\n            this._emitToConsole(\"warn\", \"MetricsLogger\", [\"Could not intitialize logging cache:\", err]);\n            this.options.logLevel = MetricsLogger.NONE;\n        }\n    };\n\n    /** return the numeric log level if level in 'none, debug, log, info, warn, error' */\n    MetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n        var type = typeof level;\n        if (type === \"number\") {\n            return level;\n        }\n        if (type === \"string\") {\n            var upper = level.toUpperCase();\n            if (MetricsLogger.hasOwnProperty(upper)) {\n                return MetricsLogger[upper];\n            }\n        }\n        throw new Error(\"Unknown log level: \" + level);\n    };\n\n    //----------------------------------------------------------------------------- main entry point\n    /** record a log/message's arguments to the cache and/or the console based on level and namespace */\n    MetricsLogger.prototype.emit = function emit(level, namespace, logArguments) {\n        //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n        var self = this;\n        namespace = namespace || self.options.defaultNamespace;\n        if (!level || !logArguments) {\n            return self;\n        }\n        // add to cache if proper level\n        //TODO: respect do not track?\n        //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n        level = self._parseLevel(level);\n        if (level >= self.options.logLevel) {\n            self._addToCache(level, namespace, logArguments);\n        }\n        // also emit to consoleLogger if proper level for that\n        if (self.consoleLogger && level >= self.options.consoleLevel) {\n            self._emitToConsole(level, namespace, logArguments);\n        }\n        return self;\n    };\n\n    //----------------------------------------------------------------------------- cache\n    /** add a message to the cache and if messages.length is high enough post them to the server */\n    MetricsLogger.prototype._addToCache = function _addToCache(level, namespace, logArguments) {\n        this._emitToConsole(\"debug\", \"MetricsLogger\", [\n            \"_addToCache:\",\n            arguments,\n            this.options.addTime,\n            this.cache.length()\n        ]);\n        //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n        var self = this;\n        // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n        try {\n            var newLength = self.cache.add(self._buildEntry(level, namespace, logArguments));\n            if (newLength >= self._postSize) {\n                self._postCache();\n            }\n            // discard entry if an error occurs, but warn if level set to do so\n        } catch (err) {\n            self._emitToConsole(\"warn\", \"MetricsLogger\", [\n                \"Metrics logger could not stringify logArguments:\",\n                namespace,\n                logArguments\n            ]);\n            self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n        }\n        return self;\n    };\n\n    /** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\n    MetricsLogger.prototype._buildEntry = function _buildEntry(level, namespace, logArguments) {\n        this._emitToConsole(\"debug\", \"MetricsLogger\", [\"_buildEntry:\", arguments]);\n        var entry = {\n            level: level,\n            namespace: this.options.clientPrefix + namespace,\n            args: logArguments\n        };\n        if (this.options.addTime) {\n            entry.time = new Date().toISOString();\n        }\n        return entry;\n    };\n\n    /** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\n    MetricsLogger.prototype._postCache = function _postCache(options) {\n        options = options || {};\n        this._emitToConsole(\"info\", \"MetricsLogger\", [\"_postCache\", options, this._postSize]);\n\n        // short circuit if we're already sending\n        if (!this.options.postUrl || this._sending) {\n            return jQuery.when({});\n        }\n\n        var self = this,\n            postSize = options.count || self._postSize,\n            // do not splice - remove after *successful* post\n            entries = self.cache.get(postSize),\n            entriesLength = entries.length,\n            // use the optional getPingData to add any extra info we may want to send\n            postData = typeof self.options.getPingData === \"function\" ? self.options.getPingData() : {};\n        //console.debug( postSize, entriesLength );\n\n        // add the metrics and send\n        postData.metrics = JSON.stringify(entries);\n        //console.debug( postData.metrics );\n        self._sending = true;\n        return jQuery\n            .post(self.options.postUrl, postData)\n            .always(function() {\n                self._sending = false;\n            })\n            .fail(function(xhr, status, message) {\n                // if we failed the previous time, set the next post target to the max num of entries\n                self._postSize = self.options.maxCacheSize;\n                //TODO:??\n                // log this failure to explain any gap in metrics\n                self.emit(\"error\", \"MetricsLogger\", [\n                    \"_postCache error:\",\n                    xhr.readyState,\n                    xhr.status,\n                    xhr.responseJSON || xhr.responseText\n                ]);\n                //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n                //TODO: see _delayPost\n            })\n            .done(function(response) {\n                if (typeof self.options.onServerResponse === \"function\") {\n                    self.options.onServerResponse(response);\n                }\n                // only remove if post successful\n                self.cache.remove(entriesLength);\n                //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n                // if we succeeded, reset the post target to the normal num of entries\n                self._postSize = self.options.postSize;\n            });\n        // return the xhr promise\n    };\n\n    /** set _waiting to true and, after delayPostInMs, set it back to false */\n    MetricsLogger.prototype._delayPost = function _delayPost() {\n        //TODO: this won't work between pages\n        var self = this;\n        self._waiting = setTimeout(function() {\n            self._waiting = null;\n        }, self.options.delayPostInMs);\n    };\n\n    //----------------------------------------------------------------------------- console\n    /** output message to console based on level and consoleLogger type */\n    MetricsLogger.prototype._emitToConsole = function _emitToConsole(level, namespace, logArguments) {\n        //console.debug( '_emitToConsole:', level, namespace, logArguments );\n        var self = this,\n            whitelist = self.options.consoleNamespaceWhitelist;\n        if (!self.consoleLogger) {\n            return self;\n        }\n        // if a whitelist for namespaces is set, bail if this namespace is not in the list\n        if (whitelist && whitelist.indexOf(namespace) === -1) {\n            return self;\n        }\n\n        var args = Array.prototype.slice.call(logArguments, 0);\n        args.unshift(namespace);\n        //TODO: script location and/or source maps?\n        //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n        if (level >= MetricsLogger.METRIC && typeof self.consoleLogger.info === \"function\") {\n            return self.consoleLogger.info.apply(self.consoleLogger, args);\n        } else if (level >= MetricsLogger.ERROR && typeof self.consoleLogger.error === \"function\") {\n            return self.consoleLogger.error.apply(self.consoleLogger, args);\n        } else if (level >= MetricsLogger.WARN && typeof self.consoleLogger.warn === \"function\") {\n            self.consoleLogger.warn.apply(self.consoleLogger, args);\n        } else if (level >= MetricsLogger.INFO && typeof self.consoleLogger.info === \"function\") {\n            self.consoleLogger.info.apply(self.consoleLogger, args);\n        } else if (level >= MetricsLogger.DEBUG && typeof self.consoleLogger.debug === \"function\") {\n            self.consoleLogger.debug.apply(self.consoleLogger, args);\n        } else if (typeof self.consoleLogger.log === \"function\") {\n            self.consoleLogger.log.apply(self.consoleLogger, args);\n        }\n        return self;\n    };\n\n    //----------------------------------------------------------------------------- shortcuts\n    // generic functions when logging from non-namespaced object (e.g. templates)\n    /** log to default namespace */\n    MetricsLogger.prototype.log = function log() {\n        this.emit(1, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n    };\n\n    /** debug to default namespace */\n    MetricsLogger.prototype.debug = function debug() {\n        this.emit(MetricsLogger.DEBUG, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n    };\n\n    /** info to default namespace */\n    MetricsLogger.prototype.info = function info() {\n        this.emit(MetricsLogger.INFO, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n    };\n\n    /** warn to default namespace */\n    MetricsLogger.prototype.warn = function warn() {\n        this.emit(MetricsLogger.WARN, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n    };\n\n    /** error to default namespace */\n    MetricsLogger.prototype.error = function error() {\n        this.emit(MetricsLogger.ERROR, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n    };\n\n    /** metric to default namespace */\n    MetricsLogger.prototype.metric = function metric() {\n        this.emit(MetricsLogger.METRIC, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n    };\n\n    /* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n    /** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\n    function LoggingCache(options) {\n        var self = this;\n        return self._init(options || {});\n    }\n\n    /** default options */\n    LoggingCache.defaultOptions = {\n        /** maximum number of entries to keep before discarding oldest */\n        maxSize: 5000\n    };\n\n    /** initialize with options */\n    LoggingCache.prototype._init = function _init(options) {\n        if (!this._hasStorage()) {\n            //TODO: fall back to jstorage\n            throw new Error(\"LoggingCache needs localStorage\");\n        }\n        if (!options.key) {\n            throw new Error(\"LoggingCache needs key for localStorage\");\n        }\n        this.key = options.key;\n        this._initStorage();\n\n        this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n        return this;\n    };\n\n    /** tests for localStorage fns */\n    LoggingCache.prototype._hasStorage = function _hasStorage() {\n        //TODO: modernizr\n        var test = \"test\";\n        try {\n            localStorage.setItem(test, test);\n            localStorage.removeItem(test);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /** if no localStorage set for key, initialize to empty array */\n    LoggingCache.prototype._initStorage = function _initStorage() {\n        if (localStorage.getItem(this.key) === null) {\n            return this.empty();\n        }\n        return this;\n    };\n\n    /** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\n    LoggingCache.prototype.add = function add(entry) {\n        var self = this,\n            _cache = self._fetchAndParse(),\n            overage = _cache.length + 1 - self.maxSize;\n        if (overage > 0) {\n            _cache.splice(0, overage);\n        }\n        _cache.push(entry);\n        self._unparseAndStore(_cache);\n        return _cache.length;\n    };\n\n    /** get the entries from localStorage and parse them */\n    LoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n        var self = this;\n        return JSON.parse(localStorage.getItem(self.key));\n    };\n\n    /** stringify the entries and put them in localStorage */\n    LoggingCache.prototype._unparseAndStore = function _unparseAndStore(entries) {\n        var self = this;\n        return localStorage.setItem(self.key, JSON.stringify(entries));\n    };\n\n    ///** process the entry before caching */\n    //LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n    //    return JSON.stringify( entry );\n    //};\n\n    /** return the length --- oh, getters where are you? */\n    LoggingCache.prototype.length = function length() {\n        return this._fetchAndParse().length;\n    };\n\n    /** get count number of entries starting with the oldest */\n    LoggingCache.prototype.get = function get(count) {\n        return this._fetchAndParse().slice(0, count);\n    };\n\n    /** remove count number of entries starting with the oldest */\n    LoggingCache.prototype.remove = function remove(count) {\n        var _cache = this._fetchAndParse(),\n            removed = _cache.splice(0, count);\n        this._unparseAndStore(_cache);\n        return removed;\n    };\n\n    /** empty/clear the entire cache */\n    LoggingCache.prototype.empty = function empty() {\n        localStorage.setItem(this.key, \"[]\");\n        return this;\n    };\n\n    /** stringify count number of entries (but do not remove) */\n    LoggingCache.prototype.stringify = function stringify(count) {\n        return JSON.stringify(this.get(count));\n    };\n\n    /** outputs entire cache to console */\n    LoggingCache.prototype.print = function print() {\n        // popup? (really, carl? a popup?) - easier to copy/paste\n        console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n    };\n\n    //=============================================================================\n    return {\n        MetricsLogger: MetricsLogger,\n        LoggingCache: LoggingCache\n    };\n});\n"]}