{"version":3,"sources":["viz/circster.js"],"names":["require","mod_utils","cssLoadFile","define","_","d3","visualization","config","mod_icon_btn","SVGUtils","Backbone","Model","extend","is_visible","svg_elt","eltBRect","getBoundingClientRect","svgBRect","$","right","bottom","drawTicks","parent_elt","data","dataHandler","textTransform","horizontal","ticks","append","selectAll","tick_coords","text_coords","text_anchor","angle","enter","d","Math","PI","radius","attr","rval","sigDigits","num","roundedNum","label","formatNum","undefined","CircsterLabelTrack","toPrecision","round","abs","options","label_arc_height","circular_views","toFixed","CircsterView","model","View","className","track","initialize","this","genome","scale","get_chord_tracks","get","on","add_track","remove_track","vis_config","update_track_bounds","get_tracks_bounds","get_circular_tracks","filter","radius_start","circular_tracks","min_dimension","self","tracks_start_radii","get_value","width","$el","height","tracks_bounds","length","dataset_arc_height","track_gap","call","range","render","chords_tracks","total_gap","svg","select","radius_bounds","index","event","translate","zoom_drag_timeout","setTimeout","map","track_bounds","label_track_view","view","chords_views","innermost_radius_bounds","new_view","CircsterChromInteractionsTrackView","outermost_radius","each","CircsterChromLabelTrackView","track_view","update_radius_bounds","track_index","new_track","el","push","remove","i","new_track_bounds","tracks","data_bounds","get_fill_color","color","CircsterTrackView","tagName","genome_arcs","chroms_elts","track_parent_elt","bg_stroke","chroms_paths","bg_fill","text","chroms_layout","_chroms_layout","data_manager","data_ready_deferred","when","_render_data","then","render_labels","arc_gen","innerRadius","_transition_labels","style","loading_bg_fill","chrom","data_is_ready","new_d","path_elt","outerRadius","transition","duration","_transition_chrom_data","update_scale","new_scale","old_scale","num_paths","path_data","path_fn","_get_path_function","data_deferred","p_data","chrom_region","get_chrom_region","get_more_detailed_data","_update_data_bounds","find","layout","_render_chrom_data","chrom_arc","set_value","silent","chrom_arcs","chrom_data_paths","layout_and_data","genome_wide_data","chrom_info","chrom_data","rendered_deferred","resolve","path","new_bounds","new_endAngle","arc","endAngle","get_data_bounds","get_genome_wide_data","prototype","Deferred","startAngle","k","chroms_info","get_chroms_info","init_arcs","value","len","sort","pie_layout","UsesTicks","gap_per_chrom","CircsterQuantitativeTrackView","_update_min_max","track_config","min_arc_len","quantile","numbers","parent","c","v","tick","ConfigSettingCollectionView","collection","_quantile","ascending","labeledChroms","datum","clamp","linear","domain","radial","interpolate","area","parseInt","line","_data_bounds_ticks_fn","classed","cur_chrom","chrom_chord_data","render_in_modal","target_angle","visibleChroms","chrom_angle_data","new_data","flatten","viz_view","icon_class","title","vis","add_tracks","p","min","values","max","url","type","id","dbkey","chord_data","success","vis_info","modal","body","source_angle","_get_region_angle","buttons","Cancel","Galaxy","target","concat","chord","position","chrom_layout","GalaxyApp","Genome","galaxy_config","app","GenomeVisualization","viz_config","add","key","hidden","menu","create_icon_buttons_menu","on_click","select_datasets","show","ajax","root","dataType","vis_json","JSON","stringify","hide","set","vis_id","error","window","location","tooltip_config","placement","tooltip"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["// load required libraries\nrequire([\"utils/utils\"], function(mod_utils) {\n    // load css\n    mod_utils.cssLoadFile(\"static/style/circster.css\");\n});\n\ndefine(\n    [\"libs/underscore\", \"libs/d3\", \"viz/visualization\", \"utils/config\", \"mvc/ui/icon-button\", \"libs/farbtastic\"],\n    function(_, d3, visualization, config, mod_icon_btn) {\n        /**\n * Utility class for working with SVG.\n */\n        var SVGUtils = Backbone.Model.extend({\n            /**\n     * Returns true if element is visible.\n     */\n            is_visible: function(svg_elt, svg) {\n                var eltBRect = svg_elt.getBoundingClientRect(),\n                    svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n                if (\n                    // To the left of screen?\n                    eltBRect.right < 0 ||\n                    // To the right of screen?\n                    eltBRect.left > svgBRect.right ||\n                    // Above screen?\n                    eltBRect.bottom < 0 ||\n                    // Below screen?\n                    eltBRect.top > svgBRect.bottom\n                ) {\n                    return false;\n                }\n                return true;\n            }\n        });\n\n        /**\n * Mixin for using ticks.\n */\n        var UsesTicks = {\n            drawTicks: function(parent_elt, data, dataHandler, textTransform, horizontal) {\n                // Set up group elements for chroms and for each tick.\n                var ticks = parent_elt\n                    .append(\"g\")\n                    .selectAll(\"g\")\n                    .data(data)\n                    .enter()\n                    .append(\"g\")\n                    .selectAll(\"g\")\n                    .data(dataHandler)\n                    .enter()\n                    .append(\"g\")\n                    .attr(\"class\", \"tick\")\n                    .attr(\"transform\", function(d) {\n                        return \"rotate(\" + (d.angle * 180 / Math.PI - 90) + \")\" + \"translate(\" + d.radius + \",0)\";\n                    });\n\n                // Add line + text for ticks.\n                var tick_coords = [],\n                    text_coords = [],\n                    text_anchor = function(d) {\n                        return d.angle > Math.PI ? \"end\" : null;\n                    };\n                if (horizontal) {\n                    tick_coords = [0, 0, 0, -4];\n                    text_coords = [4, 0, \"\", \".35em\"];\n                    text_anchor = null;\n                } else {\n                    tick_coords = [1, 0, 4, 0];\n                    text_coords = [0, 4, \".35em\", \"\"];\n                }\n\n                ticks\n                    .append(\"line\")\n                    .attr(\"x1\", tick_coords[0])\n                    .attr(\"y1\", tick_coords[1])\n                    .attr(\"x2\", tick_coords[2])\n                    .attr(\"y1\", tick_coords[3])\n                    .style(\"stroke\", \"#000\");\n\n                return ticks\n                    .append(\"text\")\n                    .attr(\"x\", text_coords[0])\n                    .attr(\"y\", text_coords[1])\n                    .attr(\"dx\", text_coords[2])\n                    .attr(\"dy\", text_coords[3])\n                    .attr(\"text-anchor\", text_anchor)\n                    .attr(\"transform\", textTransform)\n                    .text(function(d) {\n                        return d.label;\n                    });\n            },\n\n            /**\n     * Format number for display at a tick.\n     */\n            formatNum: function(num, sigDigits) {\n                // Use default of 2 sig. digits.\n                if (sigDigits === undefined) sigDigits = 2;\n\n                // Verify input number\n                if (num === null) return null;\n\n                // Calculate return value\n                var rval = null;\n                if (Math.abs(num) < 1) {\n                    rval = num.toPrecision(sigDigits);\n                } else {\n                    // Use round to turn string from toPrecision() back into a number.\n                    var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n                    // Use abbreviations.\n                    num = Math.abs(num);\n                    if (num < 1000) {\n                        rval = roundedNum;\n                    } else if (num < 1000000) {\n                        // Use K.\n                        rval = Math.round((roundedNum / 1000).toPrecision(3)).toFixed(0) + \"K\";\n                    } else if (num < 1000000000) {\n                        // Use M.\n                        rval = Math.round((roundedNum / 1000000).toPrecision(3)).toFixed(0) + \"M\";\n                    }\n                }\n\n                return rval;\n            }\n        };\n\n        /**\n * A label track.\n */\n        var CircsterLabelTrack = Backbone.Model.extend({});\n\n        /**\n * Renders a full circster visualization.\n */\n        var CircsterView = Backbone.View.extend({\n            className: \"circster\",\n\n            initialize: function(options) {\n                this.genome = options.genome;\n                this.label_arc_height = 50;\n                this.scale = 1;\n                this.circular_views = null;\n                this.chords_views = null;\n\n                // When tracks added to/removed from model, update view.\n                this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n                this.model.get(\"drawables\").on(\"remove\", this.remove_track, this);\n\n                // When config settings change, update view.\n                var vis_config = this.model.get(\"config\");\n                vis_config.get(\"arc_dataset_height\").on(\"change:value\", this.update_track_bounds, this);\n                vis_config.get(\"track_gap\").on(\"change:value\", this.update_track_bounds, this);\n            },\n\n            // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n            /**\n     * Returns tracks to be rendered using circular view.\n     */\n            get_circular_tracks: function() {\n                return this.model.get(\"drawables\").filter(function(track) {\n                    return track.get(\"track_type\") !== \"DiagonalHeatmapTrack\";\n                });\n            },\n\n            /**\n     * Returns tracks to be rendered using chords view.\n     */\n            get_chord_tracks: function() {\n                return this.model.get(\"drawables\").filter(function(track) {\n                    return track.get(\"track_type\") === \"DiagonalHeatmapTrack\";\n                });\n            },\n\n            /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n            get_tracks_bounds: function() {\n                var circular_tracks = this.get_circular_tracks(),\n                    dataset_arc_height = this.model.get(\"config\").get_value(\"arc_dataset_height\"),\n                    track_gap = this.model.get(\"config\").get_value(\"track_gap\"),\n                    // Subtract 20 to make sure chrom labels are on screen.\n                    min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20,\n                    // Compute radius start based on model, will be centered\n                    // and fit entirely inside element by default.\n                    radius_start =\n                        min_dimension / 2 -\n                        circular_tracks.length * (dataset_arc_height + track_gap) +\n                        // Add track_gap back in because no gap is needed for last track.\n                        track_gap -\n                        this.label_arc_height,\n                    // Compute range of track starting radii.\n                    tracks_start_radii = d3.range(radius_start, min_dimension / 2, dataset_arc_height + track_gap);\n\n                // Map from track start to bounds.\n                var self = this;\n                return _.map(tracks_start_radii, function(radius) {\n                    return [radius, radius + dataset_arc_height];\n                });\n            },\n\n            /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n            render: function() {\n                var self = this,\n                    width = self.$el.width(),\n                    height = self.$el.height(),\n                    circular_tracks = this.get_circular_tracks(),\n                    chords_tracks = this.get_chord_tracks(),\n                    total_gap = self.model.get(\"config\").get_value(\"total_gap\"),\n                    tracks_bounds = this.get_tracks_bounds(),\n                    // Set up SVG element.\n                    svg = d3\n                        .select(self.$el[0])\n                        .append(\"svg\")\n                        .attr(\"width\", width)\n                        .attr(\"height\", height)\n                        .attr(\"pointer-events\", \"all\")\n                        // Set up zooming, dragging.\n                        .append(\"svg:g\")\n                        .call(\n                            d3.behavior.zoom().on(\"zoom\", function() {\n                                // Do zoom, drag.\n                                var scale = d3.event.scale;\n                                svg.attr(\n                                    \"transform\",\n                                    \"translate(\" + d3.event.translate + \")\" + \" scale(\" + scale + \")\"\n                                );\n\n                                // Propagate scale changes to views.\n                                if (self.scale !== scale) {\n                                    // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                                    if (self.zoom_drag_timeout) {\n                                        clearTimeout(self.zoom_drag_timeout);\n                                    }\n                                    self.zoom_drag_timeout = setTimeout(function() {\n                                        // Render more detail in tracks' visible elements.\n                                        // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                                        // are not updated when new data is fetched--and fetching more detailed quantitative\n                                        // data is not that useful.\n                                        /*\n                            _.each(self.circular_views, function(view) {\n                                view.update_scale(scale);\n                            });\n                            */\n                                    }, 400);\n                                }\n                            })\n                        )\n                        .attr(\"transform\", \"translate(\" + width / 2 + \",\" + height / 2 + \")\")\n                        .append(\"svg:g\")\n                        .attr(\"class\", \"tracks\");\n\n                // -- Render circular tracks. --\n\n                // Create a view for each track in the visualization and render.\n                this.circular_views = circular_tracks.map(function(track, index) {\n                    var view = new CircsterBigWigTrackView({\n                        el: svg.append(\"g\")[0],\n                        track: track,\n                        radius_bounds: tracks_bounds[index],\n                        genome: self.genome,\n                        total_gap: total_gap\n                    });\n\n                    view.render();\n\n                    return view;\n                });\n\n                // -- Render chords tracks. --\n\n                this.chords_views = chords_tracks.map(function(track) {\n                    var view = new CircsterChromInteractionsTrackView({\n                        el: svg.append(\"g\")[0],\n                        track: track,\n                        radius_bounds: tracks_bounds[0],\n                        genome: self.genome,\n                        total_gap: total_gap\n                    });\n\n                    view.render();\n\n                    return view;\n                });\n\n                // -- Render label track. --\n\n                // Track bounds are:\n                // (a) outer radius of last circular track;\n                // (b)\n                var outermost_radius = this.circular_views[this.circular_views.length - 1].radius_bounds[1],\n                    track_bounds = [outermost_radius, outermost_radius + this.label_arc_height];\n                this.label_track_view = new CircsterChromLabelTrackView({\n                    el: svg.append(\"g\")[0],\n                    track: new CircsterLabelTrack(),\n                    radius_bounds: track_bounds,\n                    genome: self.genome,\n                    total_gap: total_gap\n                });\n\n                this.label_track_view.render();\n            },\n\n            /**\n     * Render a single track on the outside of the current visualization.\n     */\n            add_track: function(new_track) {\n                var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n                if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n                    // Added chords track.\n                    var innermost_radius_bounds = this.circular_views[0].radius_bounds,\n                        new_view = new CircsterChromInteractionsTrackView({\n                            el: d3.select(\"g.tracks\").append(\"g\")[0],\n                            track: new_track,\n                            radius_bounds: innermost_radius_bounds,\n                            genome: this.genome,\n                            total_gap: total_gap\n                        });\n                    new_view.render();\n                    this.chords_views.push(new_view);\n                } else {\n                    // Added circular track.\n\n                    // Recompute and update circular track bounds.\n                    var new_track_bounds = this.get_tracks_bounds();\n                    _.each(this.circular_views, function(track_view, i) {\n                        track_view.update_radius_bounds(new_track_bounds[i]);\n                    });\n\n                    // Update chords tracks.\n                    _.each(this.chords_views, function(track_view) {\n                        track_view.update_radius_bounds(new_track_bounds[0]);\n                    });\n\n                    // Render new track.\n                    var track_index = this.circular_views.length,\n                        track_view = new CircsterBigWigTrackView({\n                            el: d3.select(\"g.tracks\").append(\"g\")[0],\n                            track: new_track,\n                            radius_bounds: new_track_bounds[track_index],\n                            genome: this.genome,\n                            total_gap: total_gap\n                        });\n                    track_view.render();\n                    this.circular_views.push(track_view);\n\n                    // Update label track.\n                    /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n                }\n            },\n\n            /**\n     * Remove a track from the view.\n     */\n            remove_track: function(track, tracks, options) {\n                // -- Remove track from view. --\n                var track_view = this.circular_views[options.index];\n                this.circular_views.splice(options.index, 1);\n                track_view.$el.remove();\n\n                // Recompute and update track bounds.\n                var new_track_bounds = this.get_tracks_bounds();\n                _.each(this.circular_views, function(track_view, i) {\n                    track_view.update_radius_bounds(new_track_bounds[i]);\n                });\n            },\n\n            update_track_bounds: function() {\n                // Recompute and update track bounds.\n                var new_track_bounds = this.get_tracks_bounds();\n                _.each(this.circular_views, function(track_view, i) {\n                    track_view.update_radius_bounds(new_track_bounds[i]);\n                });\n\n                // Update chords tracks.\n                _.each(this.chords_views, function(track_view) {\n                    track_view.update_radius_bounds(new_track_bounds[0]);\n                });\n            }\n        });\n\n        /**\n * Renders a track in a Circster visualization.\n */\n        var CircsterTrackView = Backbone.View.extend({\n            tagName: \"g\",\n\n            /* ----------------------- Public Methods ------------------------- */\n\n            initialize: function(options) {\n                this.bg_stroke = \"#ddd\";\n                // Fill color when loading data.\n                this.loading_bg_fill = \"#ffc\";\n                // Fill color when data has been loaded.\n                this.bg_fill = \"#ddd\";\n                this.total_gap = options.total_gap;\n                this.track = options.track;\n                this.radius_bounds = options.radius_bounds;\n                this.genome = options.genome;\n                this.chroms_layout = this._chroms_layout();\n                this.data_bounds = [];\n                this.scale = 1;\n                this.parent_elt = d3.select(this.$el[0]);\n            },\n\n            /**\n     * Get fill color from config.\n     */\n            get_fill_color: function() {\n                var color = this.track.get(\"config\").get_value(\"block_color\");\n                if (!color) {\n                    color = this.track.get(\"config\").get_value(\"color\");\n                }\n                return color;\n            },\n\n            /**\n     * Render track's data by adding SVG elements to parent.\n     */\n            render: function() {\n                // -- Create track group element. --\n                var track_parent_elt = this.parent_elt;\n\n                // -- Render background arcs. --\n                var genome_arcs = this.chroms_layout,\n                    arc_gen = d3.svg\n                        .arc()\n                        .innerRadius(this.radius_bounds[0])\n                        .outerRadius(this.radius_bounds[1]),\n                    // Attach data to group element.\n                    chroms_elts = track_parent_elt\n                        .selectAll(\"g\")\n                        .data(genome_arcs)\n                        .enter()\n                        .append(\"svg:g\"),\n                    // Draw chrom arcs/paths.\n                    chroms_paths = chroms_elts\n                        .append(\"path\")\n                        .attr(\"d\", arc_gen)\n                        .attr(\"class\", \"chrom-background\")\n                        .style(\"stroke\", this.bg_stroke)\n                        .style(\"fill\", this.loading_bg_fill);\n\n                // Append titles to paths.\n                chroms_paths.append(\"title\").text(function(d) {\n                    return d.data.chrom;\n                });\n\n                // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n                var self = this,\n                    data_manager = self.track.get(\"data_manager\"),\n                    // If track has a data manager, get deferred that resolves when data is ready.\n                    data_ready_deferred = data_manager ? data_manager.data_is_ready() : true;\n\n                // When data is ready, render track.\n                $.when(data_ready_deferred).then(function() {\n                    $.when(self._render_data(track_parent_elt)).then(function() {\n                        chroms_paths.style(\"fill\", self.bg_fill);\n\n                        // Render labels after data is available so that data attributes are available.\n                        self.render_labels();\n                    });\n                });\n            },\n\n            /**\n     * Render track labels.\n     */\n            render_labels: function() {},\n\n            /**\n     * Update radius bounds.\n     */\n            update_radius_bounds: function(radius_bounds) {\n                // Update bounds.\n                this.radius_bounds = radius_bounds;\n\n                // -- Update background arcs. --\n                var new_d = d3.svg\n                    .arc()\n                    .innerRadius(this.radius_bounds[0])\n                    .outerRadius(this.radius_bounds[1]);\n\n                this.parent_elt\n                    .selectAll(\"g>path.chrom-background\")\n                    .transition()\n                    .duration(1000)\n                    .attr(\"d\", new_d);\n\n                this._transition_chrom_data();\n\n                this._transition_labels();\n            },\n\n            /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n            update_scale: function(new_scale) {\n                // -- Update scale and return if new scale is less than old scale. --\n\n                var old_scale = this.scale;\n                this.scale = new_scale;\n                if (new_scale <= old_scale) {\n                    return;\n                }\n\n                // -- Scale increased, so render visible data with more detail. --\n\n                var self = this,\n                    utils = new SVGUtils();\n\n                // Select all chrom data and filter to operate on those that are visible.\n                this.parent_elt\n                    .selectAll(\"path.chrom-data\")\n                    .filter(function(d, i) {\n                        return utils.is_visible(this);\n                    })\n                    .each(function(d, i) {\n                        // -- Now operating on a single path element representing chromosome data. --\n\n                        var path_elt = d3.select(this),\n                            chrom = path_elt.attr(\"chrom\"),\n                            chrom_region = self.genome.get_chrom_region(chrom),\n                            data_manager = self.track.get(\"data_manager\"),\n                            data_deferred;\n\n                        // If can't get more detailed data, return.\n                        if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                            return;\n                        }\n\n                        // -- Get more detailed data. --\n                        data_deferred = self.track\n                            .get(\"data_manager\")\n                            .get_more_detailed_data(chrom_region, \"Coverage\", 0, new_scale);\n\n                        // When more data is available, use new data to redraw path.\n                        $.when(data_deferred).then(function(data) {\n                            // Remove current data path.\n                            path_elt.remove();\n\n                            // Update data bounds with new data.\n                            self._update_data_bounds();\n\n                            // Find chromosome arc to draw data on.\n                            var chrom_arc = _.find(self.chroms_layout, function(layout) {\n                                return layout.data.chrom === chrom;\n                            });\n\n                            // Add new data path and apply preferences.\n                            var color = self.get_fill_color();\n                            self\n                                ._render_chrom_data(self.parent_elt, chrom_arc, data)\n                                .style(\"stroke\", color)\n                                .style(\"fill\", color);\n                        });\n                    });\n\n                return self;\n            },\n\n            /* ----------------------- Internal Methods ------------------------- */\n\n            /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n            _transition_chrom_data: function() {\n                var track = this.track,\n                    chrom_arcs = this.chroms_layout,\n                    chrom_data_paths = this.parent_elt.selectAll(\"g>path.chrom-data\"),\n                    num_paths = chrom_data_paths[0].length;\n\n                if (num_paths > 0) {\n                    var self = this;\n                    $.when(track.get(\"data_manager\").get_genome_wide_data(this.genome)).then(function(\n                        genome_wide_data\n                    ) {\n                        // Map chrom data to path data, filtering out null values.\n                        var path_data = _.reject(\n                            _.map(genome_wide_data, function(chrom_data, i) {\n                                var rval = null,\n                                    path_fn = self._get_path_function(chrom_arcs[i], chrom_data);\n                                if (path_fn) {\n                                    rval = path_fn(chrom_data.data);\n                                }\n                                return rval;\n                            }),\n                            function(p_data) {\n                                return p_data === null;\n                            }\n                        );\n\n                        // Transition each path for data and color.\n                        var color = track.get(\"config\").get_value(\"color\");\n                        chrom_data_paths.each(function(path, index) {\n                            d3\n                                .select(this)\n                                .transition()\n                                .duration(1000)\n                                .style(\"stroke\", color)\n                                .style(\"fill\", color)\n                                .attr(\"d\", path_data[index]);\n                        });\n                    });\n                }\n            },\n\n            /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n            _transition_labels: function() {},\n\n            /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n            _update_data_bounds: function(new_bounds) {\n                var old_bounds = this.data_bounds;\n                this.data_bounds =\n                    new_bounds ||\n                    this.get_data_bounds(this.track.get(\"data_manager\").get_genome_wide_data(this.genome));\n                this._transition_chrom_data();\n            },\n\n            /**\n     * Render data as elements attached to svg.\n     */\n            _render_data: function(svg) {\n                var self = this,\n                    chrom_arcs = this.chroms_layout,\n                    track = this.track,\n                    rendered_deferred = $.Deferred();\n\n                // When genome-wide data is available, render data.\n                $.when(track.get(\"data_manager\").get_genome_wide_data(this.genome)).then(function(genome_wide_data) {\n                    // Set bounds.\n                    self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n                    // Set min, max value in config so that they can be adjusted. Make this silent\n                    // because these attributes are watched for changes and the viz is updated\n                    // accordingly (set up in initialize). Because we are setting up, we don't want\n                    // the watch to trigger events here.\n                    track.get(\"config\").set_value(\"min_value\", self.data_bounds[0], {\n                        silent: true\n                    });\n                    track.get(\"config\").set_value(\"max_value\", self.data_bounds[1], {\n                        silent: true\n                    });\n\n                    // Merge chroms layout with data.\n                    var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n                    // Render each chromosome's data.\n                    _.each(layout_and_data, function(chrom_info) {\n                        var chrom_arc = chrom_info[0],\n                            data = chrom_info[1];\n                        return self._render_chrom_data(svg, chrom_arc, data);\n                    });\n\n                    // Apply prefs to all track data.\n                    var color = self.get_fill_color();\n                    self.parent_elt\n                        .selectAll(\"path.chrom-data\")\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n\n                    rendered_deferred.resolve(svg);\n                });\n\n                return rendered_deferred;\n            },\n\n            /**\n     * Render a chromosome data and attach elements to svg.\n     */\n            _render_chrom_data: function(svg, chrom_arc, data) {},\n\n            /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n            _get_path_function: function(chrom_arc, chrom_data) {},\n\n            /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n            _chroms_layout: function() {\n                // Setup chroms layout using pie.\n                var chroms_info = this.genome.get_chroms_info(),\n                    pie_layout = d3.layout\n                        .pie()\n                        .value(function(d) {\n                            return d.len;\n                        })\n                        .sort(null),\n                    init_arcs = pie_layout(chroms_info),\n                    gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length,\n                    chrom_arcs = _.map(init_arcs, function(arc, index) {\n                        // For short chroms, endAngle === startAngle.\n                        var new_endAngle = arc.endAngle - gap_per_chrom;\n                        arc.endAngle = new_endAngle > arc.startAngle ? new_endAngle : arc.startAngle;\n                        return arc;\n                    });\n                return chrom_arcs;\n            }\n        });\n\n        /**\n * Render chromosome labels.\n */\n        var CircsterChromLabelTrackView = CircsterTrackView.extend({\n            initialize: function(options) {\n                CircsterTrackView.prototype.initialize.call(this, options);\n                // Use a single arc for rendering data.\n                this.innerRadius = this.radius_bounds[0];\n                this.radius_bounds[0] = this.radius_bounds[1];\n                this.bg_stroke = \"#fff\";\n                this.bg_fill = \"#fff\";\n\n                // Minimum arc distance for labels to be applied.\n                this.min_arc_len = 0.05;\n            },\n\n            /**\n     * Render labels.\n     */\n            _render_data: function(svg) {\n                // -- Add chromosome label where it will fit; an alternative labeling mechanism\n                // would be nice for small chromosomes. --\n                var self = this,\n                    chrom_arcs = svg.selectAll(\"g\");\n\n                chrom_arcs.selectAll(\"path\").attr(\"id\", function(d) {\n                    return \"label-\" + d.data.chrom;\n                });\n\n                chrom_arcs\n                    .append(\"svg:text\")\n                    .filter(function(d) {\n                        return d.endAngle - d.startAngle > self.min_arc_len;\n                    })\n                    .attr(\"text-anchor\", \"middle\")\n                    .append(\"svg:textPath\")\n                    .attr(\"class\", \"chrom-label\")\n                    .attr(\"xlink:href\", function(d) {\n                        return \"#label-\" + d.data.chrom;\n                    })\n                    .attr(\"startOffset\", \"25%\")\n                    .text(function(d) {\n                        return d.data.chrom;\n                    });\n\n                // -- Add ticks to denote chromosome length. --\n\n                /** Returns an array of tick angles and labels, given a chrom arc. */\n                var chromArcTicks = function(d) {\n                    var k = (d.endAngle - d.startAngle) / d.value,\n                        ticks = d3.range(0, d.value, 25000000).map(function(v, i) {\n                            return {\n                                radius: self.innerRadius,\n                                angle: v * k + d.startAngle,\n                                label: i === 0 ? 0 : i % 3 ? null : self.formatNum(v)\n                            };\n                        });\n\n                    // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n                    if (ticks.length < 4) {\n                        ticks[ticks.length - 1].label = self.formatNum(\n                            Math.round((ticks[ticks.length - 1].angle - d.startAngle) / k)\n                        );\n                    }\n\n                    return ticks;\n                };\n\n                /** Rotate and move text as needed. */\n                var textTransform = function(d) {\n                    return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null;\n                };\n\n                // Filter chroms for only those large enough for display.\n                var visibleChroms = _.filter(this.chroms_layout, function(c) {\n                    return c.endAngle - c.startAngle > self.min_arc_len;\n                });\n\n                this.drawTicks(this.parent_elt, visibleChroms, chromArcTicks, textTransform);\n            }\n        });\n        _.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n        /**\n * View for quantitative track in Circster.\n */\n        var CircsterQuantitativeTrackView = CircsterTrackView.extend({\n            initialize: function(options) {\n                CircsterTrackView.prototype.initialize.call(this, options);\n\n                // When config settings change, update view.\n                var track_config = this.track.get(\"config\");\n                track_config.get(\"min_value\").on(\"change:value\", this._update_min_max, this);\n                track_config.get(\"max_value\").on(\"change:value\", this._update_min_max, this);\n                track_config.get(\"color\").on(\"change:value\", this._transition_chrom_data, this);\n            },\n\n            /**\n     * Update track when min and/or max are changed.\n     */\n            _update_min_max: function() {\n                var track_config = this.track.get(\"config\"),\n                    new_bounds = [track_config.get_value(\"min_value\"), track_config.get_value(\"max_value\")];\n                this._update_data_bounds(new_bounds);\n\n                // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n                // by updating the data itself.\n                this.parent_elt.selectAll(\".min_max\").text(function(d, i) {\n                    return new_bounds[i];\n                });\n            },\n\n            /**\n     * Returns quantile for an array of numbers.\n     */\n            _quantile: function(numbers, quantile) {\n                numbers.sort(d3.ascending);\n                return d3.quantile(numbers, quantile);\n            },\n\n            /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n            _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n                var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n                if (!path_data) {\n                    return null;\n                }\n\n                // There is path data, so render as path.\n                var parent = svg.datum(chrom_data.data),\n                    path = parent\n                        .append(\"path\")\n                        .attr(\"class\", \"chrom-data\")\n                        .attr(\"chrom\", chrom_arc.data.chrom)\n                        .attr(\"d\", path_data);\n\n                return path;\n            },\n\n            /**\n     * Returns function for creating a path across the chrom arc.\n     */\n            _get_path_function: function(chrom_arc, chrom_data) {\n                // If no chrom data, return null.\n                if (typeof chrom_data === \"string\" || !chrom_data.data || chrom_data.data.length === 0) {\n                    return null;\n                }\n\n                // Radius scaler.\n                var radius = d3.scale\n                    .linear()\n                    .domain(this.data_bounds)\n                    .range(this.radius_bounds)\n                    .clamp(true);\n\n                // Scaler for placing data points across arc.\n                var angle = d3.scale\n                    .linear()\n                    .domain([0, chrom_data.data.length])\n                    .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n                // Use line generator to create area.\n                var line = d3.svg.line\n                    .radial()\n                    .interpolate(\"linear\")\n                    .radius(function(d) {\n                        return radius(d[1]);\n                    })\n                    .angle(function(d, i) {\n                        return angle(i);\n                    });\n\n                return d3.svg.area\n                    .radial()\n                    .interpolate(line.interpolate())\n                    .innerRadius(radius(0))\n                    .outerRadius(line.radius())\n                    .angle(line.angle());\n            },\n\n            /**\n     * Render track min, max using ticks.\n     */\n            render_labels: function() {\n                var self = this,\n                    // Keep counter of visible chroms.\n                    textTransform = function() {\n                        return \"rotate(90)\";\n                    };\n\n                // FIXME:\n                // (1) using min_max class below is needed for _update_min_max, which could be improved.\n                // (2) showing config on tick click should be replaced by proper track config icon.\n\n                // Draw min, max on first chrom only.\n                var ticks = this.drawTicks(\n                    this.parent_elt,\n                    [this.chroms_layout[0]],\n                    this._data_bounds_ticks_fn(),\n                    textTransform,\n                    true\n                ).classed(\"min_max\", true);\n\n                // Show config when ticks are clicked on.\n                _.each(ticks, function(tick) {\n                    $(tick).click(function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: self.track.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Track\");\n                    });\n                });\n\n                /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n            },\n\n            /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n            _transition_labels: function() {\n                // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n                // is copied from UseTicks mixin, so pull out and make generally available.\n\n                // If there are no data bounds, nothing to transition.\n                if (this.data_bounds.length === 0) {\n                    return;\n                }\n\n                // Transition labels to new radius bounds.\n                var self = this,\n                    visibleChroms = _.filter(this.chroms_layout, function(c) {\n                        return c.endAngle - c.startAngle > 0.08;\n                    }),\n                    labeledChroms = _.filter(visibleChroms, function(c, i) {\n                        return i % 3 === 0;\n                    }),\n                    new_data = _.flatten(\n                        _.map(labeledChroms, function(c) {\n                            return self._data_bounds_ticks_fn()(c);\n                        })\n                    );\n                this.parent_elt\n                    .selectAll(\"g.tick\")\n                    .data(new_data)\n                    .transition()\n                    .attr(\"transform\", function(d) {\n                        return \"rotate(\" + (d.angle * 180 / Math.PI - 90) + \")\" + \"translate(\" + d.radius + \",0)\";\n                    });\n            },\n\n            /**\n     * Get function for locating data bounds ticks.\n     */\n            _data_bounds_ticks_fn: function() {\n                // Closure vars.\n                var self = this;\n                visibleChroms = 0;\n\n                // Return function for locating ticks based on chrom arc data.\n                return function(d) {\n                    // Set up data to display min, max ticks.\n                    return [\n                        {\n                            radius: self.radius_bounds[0],\n                            angle: d.startAngle,\n                            label: self.formatNum(self.data_bounds[0])\n                        },\n                        {\n                            radius: self.radius_bounds[1],\n                            angle: d.startAngle,\n                            label: self.formatNum(self.data_bounds[1])\n                        }\n                    ];\n                };\n            },\n\n            /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n            get_data_bounds: function(data) {}\n        });\n        _.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n        /**\n * Bigwig track view in Circster.\n */\n        var CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n            get_data_bounds: function(data) {\n                // Set max across dataset by extracting all values, flattening them into a\n                // single array, and getting third quartile.\n                var values = _.flatten(\n                    _.map(data, function(d) {\n                        if (d) {\n                            // Each data point has the form [position, value], so return all values.\n                            return _.map(d.data, function(p) {\n                                // Null is used for a lack of data; resolve null to 0 for comparison.\n                                return parseInt(p[1], 10) || 0;\n                            });\n                        } else {\n                            return 0;\n                        }\n                    })\n                );\n\n                // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n                // for sparsely populated data, so use max in that case.\n                return [_.min(values), this._quantile(values, 0.98) || _.max(values)];\n            }\n        });\n\n        /**\n * Chromosome interactions track view in Circster.\n */\n        var CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n            render: function() {\n                var self = this;\n\n                // When data is ready, render track.\n                $.when(self.track.get(\"data_manager\").data_is_ready()).then(function() {\n                    // When data has been fetched, render track.\n                    $.when(self.track.get(\"data_manager\").get_genome_wide_data(self.genome)).then(function(\n                        genome_wide_data\n                    ) {\n                        var chord_data = [],\n                            chroms_info = self.genome.get_chroms_info();\n                        // Convert chromosome data into chord data.\n                        _.each(genome_wide_data, function(chrom_data, index) {\n                            // Map each interaction into chord data.\n                            var cur_chrom = chroms_info[index].chrom;\n                            var chrom_chord_data = _.map(chrom_data.data, function(datum) {\n                                // Each datum is an interaction/chord.\n                                var source_angle = self._get_region_angle(cur_chrom, datum[1]),\n                                    target_angle = self._get_region_angle(datum[3], datum[4]);\n                                return {\n                                    source: {\n                                        startAngle: source_angle,\n                                        endAngle: source_angle + 0.01\n                                    },\n                                    target: {\n                                        startAngle: target_angle,\n                                        endAngle: target_angle + 0.01\n                                    }\n                                };\n                            });\n\n                            chord_data = chord_data.concat(chrom_chord_data);\n                        });\n\n                        self.parent_elt\n                            .append(\"g\")\n                            .attr(\"class\", \"chord\")\n                            .selectAll(\"path\")\n                            .data(chord_data)\n                            .enter()\n                            .append(\"path\")\n                            .style(\"fill\", self.get_fill_color())\n                            .attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0]))\n                            .style(\"opacity\", 1);\n                    });\n                });\n            },\n\n            update_radius_bounds: function(radius_bounds) {\n                this.radius_bounds = radius_bounds;\n                this.parent_elt\n                    .selectAll(\"path\")\n                    .transition()\n                    .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n            },\n\n            /**\n     * Returns radians for a genomic position.\n     */\n            _get_region_angle: function(chrom, position) {\n                // Find chrom angle data\n                var chrom_angle_data = _.find(this.chroms_layout, function(chrom_layout) {\n                    return chrom_layout.data.chrom === chrom;\n                });\n\n                // Return angle at position.\n                return (\n                    chrom_angle_data.endAngle -\n                    (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                        (chrom_angle_data.data.len - position) /\n                        chrom_angle_data.data.len\n                );\n            }\n        });\n\n        // circster app loader\n        var Circster = Backbone.View.extend({\n            initialize: function() {\n                // -- Configure visualization --\n                var genome = new visualization.Genome(galaxy_config.app.genome),\n                    vis = new visualization.GenomeVisualization(galaxy_config.app.viz_config);\n\n                // Add Circster-specific config options.\n                vis.get(\"config\").add([\n                    {\n                        key: \"arc_dataset_height\",\n                        label: \"Arc Dataset Height\",\n                        type: \"int\",\n                        value: 25,\n                        view: \"circster\"\n                    },\n                    {\n                        key: \"track_gap\",\n                        label: \"Gap Between Tracks\",\n                        type: \"int\",\n                        value: 5,\n                        view: \"circster\"\n                    },\n                    {\n                        key: \"total_gap\",\n                        label: \"Gap [0-1]\",\n                        type: \"float\",\n                        value: 0.4,\n                        view: \"circster\",\n                        hidden: true\n                    }\n                ]);\n\n                var viz_view = new CircsterView({\n                    // view pane\n                    el: $(\"#center .unified-panel-body\"),\n                    genome: genome,\n                    model: vis\n                });\n\n                // Render vizualization\n                viz_view.render();\n\n                // setup title\n                $(\"#center .unified-panel-header-inner\").append(\n                    galaxy_config.app.viz_config.title + \" \" + galaxy_config.app.viz_config.dbkey\n                );\n\n                // setup menu\n                var menu = mod_icon_btn.create_icon_buttons_menu(\n                    [\n                        {\n                            icon_class: \"plus-button\",\n                            title: \"Add tracks\",\n                            on_click: function() {\n                                visualization.select_datasets({ dbkey: vis.get(\"dbkey\") }, function(tracks) {\n                                    vis.add_tracks(tracks);\n                                });\n                            }\n                        },\n                        {\n                            icon_class: \"gear\",\n                            title: \"Settings\",\n                            on_click: function() {\n                                var view = new config.ConfigSettingCollectionView({\n                                    collection: vis.get(\"config\")\n                                });\n                                view.render_in_modal(\"Configure Visualization\");\n                            }\n                        },\n                        {\n                            icon_class: \"disk--arrow\",\n                            title: \"Save\",\n                            on_click: function() {\n                                // show saving dialog box\n                                Galaxy.modal.show({\n                                    title: \"Saving...\",\n                                    body: \"progress\"\n                                });\n\n                                // send to server\n                                $.ajax({\n                                    url: Galaxy.root + \"visualization/save\",\n                                    type: \"POST\",\n                                    dataType: \"json\",\n                                    data: {\n                                        id: vis.get(\"vis_id\"),\n                                        title: vis.get(\"title\"),\n                                        dbkey: vis.get(\"dbkey\"),\n                                        type: \"trackster\",\n                                        vis_json: JSON.stringify(vis)\n                                    }\n                                })\n                                    .success(function(vis_info) {\n                                        Galaxy.modal.hide();\n                                        vis.set(\"vis_id\", vis_info.vis_id);\n                                    })\n                                    .error(function() {\n                                        // show dialog\n                                        Galaxy.modal.show({\n                                            title: \"Could Not Save\",\n                                            body: \"Could not save visualization. Please try again later.\",\n                                            buttons: {\n                                                Cancel: function() {\n                                                    Galaxy.modal.hide();\n                                                }\n                                            }\n                                        });\n                                    });\n                            }\n                        },\n                        {\n                            icon_class: \"cross-circle\",\n                            title: \"Close\",\n                            on_click: function() {\n                                window.location = Galaxy.root + \"visualizations/list\";\n                            }\n                        }\n                    ],\n                    { tooltip_config: { placement: \"bottom\" } }\n                );\n\n                // add menu\n                menu.$el.attr(\"style\", \"float: right\");\n                $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n                // manual tooltip config because default gravity is S and cannot be changed\n                $(\".menu-button\").tooltip({ placement: \"bottom\" });\n            }\n        });\n\n        // Module exports.\n        return {\n            GalaxyApp: Circster\n        };\n    }\n);\n"]}