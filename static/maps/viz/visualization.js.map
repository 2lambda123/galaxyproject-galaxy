{"version":3,"sources":["viz/visualization.js"],"names":["define","CustomToJSON","_","data_mod","util_mod","config_mod","GridView","Tabs","Ui","json","self","this","each","constructor","to_json_keys","k","val","get","to_json_mappers","CanvasManager","default_font","load_pattern","undefined","new_canvas","dummy_canvas","getContext","dummy_context","font","prototype","measureText","width","patterns","image","Galaxy","createPattern","extend","key","path","canvas","Image","manager","root","get_pattern","Backbone","Model","num_elements","Cache","defaults","obj_cache","initialize","options","clear","get_elt","key_str","attributes","key_ary","splice","index","indexOf","toString","stale","move_key_to_end","set_elt","value","deleted_key","shift","length","push","most_recently_added","size","dataset","genome","init_data","filters_manager","GenomeDataManager","min_region_size","data_mode_compatible","entry","mode","initial_entries","add_data","call","entries","set","set_data","region","data_is_ready","dataType","ready_deferred","$","Deferred","query_type","ss_deferred","then","ServerStateDeferred","url","hda_ldda","data_type","search_features","response","when","go","load_data","params","query","high","resolution","extra_params","filter_names","filters","chrom","filter_cols","result","i","name","JSON","stringify","get_data","is_subregion","entry_region","is_deferred","subset_entry","contains","copy","last_request","BROAD_DATA_REQ","trim","DEEP_DATA_REQ","query_low","get_more_data","req_type","cur_data","new_data_request","new_data_available","max_low","data","query_region","message","resolve","can_get_more_detailed_data","concat","dataset_type","replace","data_manager","get_more_detailed_data","detail_multiplier","_mark_stale","console","num_samples","log","end","gw_data","chrom_data","start","get_genome_wide_data","all_data_available","map","chrom_info","GenomeRegion","len","subset_fns","bigwig","refseq","getJSON","seq_start","genome_wide_data","deferred","subregion","subregion_data","data_point","GenomeReferenceDataManager","same","chroms_info","dataset_placeholder","urlRoot","data_url","get_chroms_info","Genome","id","dbkey","get_chrom_region","chr_name","find","str_val","get_chrom_len","pieces","from_str","parseInt","split","start_end","on","first_start","second_start","a_region","first_end","second_end","overlap","overlap_results","toJSON","compute_overlap","first_chrom","second_chrom","DIF_CHROMS","BEFORE","CONTAINS","AFTER","CONTAINED_BY","OVERLAP_END","OVERLAP_START","GenomeRegionCollection","Collection","chrom_len","BrowserBookmark","overlaps","BrowserBookmarkCollection","models","default_value","ConfigSettingCollection","preloaded_data","model","color","d","Dataset","BackboneTrack","label","type","from_models_and_saved_values","prefs","bookmarks","viewport","p","BackboneTrackCollection","content_visible","drawables","save","ajax","TrackBrowserRouter","view","vis_json","GenomeVisualization","Visualization","change_location","new_loc","tracks","select_datasets","add_tracks","add","dummy","obj_type","Router","route","navigate","go_to","success_fn","library_grid","url_base","dict_format","embedded","title","$el","View","append","history_grid","body","tabs","closing_events","buttons","Add","show","window","requests","current","apply","track_defs","arguments","Array","arg","modal"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["define(\n    [\n        \"libs/underscore\",\n        \"mvc/dataset/data\",\n        \"viz/trackster/util\",\n        \"utils/config\",\n        \"mvc/grid/grid-view\",\n        \"mvc/ui/ui-tabs\",\n        \"mvc/ui/ui-misc\"\n    ],\n    function(_, data_mod, util_mod, config_mod, GridView, Tabs, Ui) {\n        /**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\n        var CustomToJSON = {\n            /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n            toJSON: function() {\n                var self = this,\n                    json = {};\n                _.each(self.constructor.to_json_keys, function(k) {\n                    var val = self.get(k);\n                    if (k in self.constructor.to_json_mappers) {\n                        val = self.constructor.to_json_mappers[k](val, self);\n                    }\n                    json[k] = val;\n                });\n                return json;\n            }\n        };\n\n        /**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n        /**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\n        var select_datasets = function(filters, success_fn) {\n            // history dataset selection tab\n            var history_grid = new GridView({\n                url_base: Galaxy.root + \"visualization/list_history_datasets\",\n                filters: filters,\n                dict_format: true,\n                embedded: true\n            });\n\n            // library dataset selection tab\n            var library_grid = new GridView({\n                url_base: Galaxy.root + \"visualization/list_library_datasets\",\n                dict_format: true,\n                embedded: true\n            });\n\n            // build tabs\n            var tabs = new Tabs.View();\n            tabs.add({\n                id: \"histories\",\n                title: \"Histories\",\n                $el: $(\"<div/>\").append(history_grid.$el)\n            });\n            tabs.add({\n                id: \"libraries\",\n                title: \"Libraries\",\n                $el: $(\"<div/>\").append(library_grid.$el)\n            });\n\n            // modal\n            Galaxy.modal.show({\n                title: \"Select datasets for new tracks\",\n                body: tabs.$el,\n                closing_events: true,\n                buttons: {\n                    Cancel: function() {\n                        Galaxy.modal.hide();\n                    },\n                    Add: function() {\n                        var requests = [];\n                        tabs.$(\"input.grid-row-select-checkbox[name=id]:checked\").each(function() {\n                            window.console.log($(this).val());\n                            requests[requests.length] = $.ajax({\n                                url: Galaxy.root + \"api/datasets/\" + $(this).val(),\n                                dataType: \"json\",\n                                data: {\n                                    data_type: \"track_config\",\n                                    hda_ldda: tabs.current() == \"histories\" ? \"hda\" : \"ldda\"\n                                }\n                            });\n                        });\n                        // To preserve order, wait until there are definitions for all tracks and then add\n                        // them sequentially.\n                        $.when.apply($, requests).then(function() {\n                            // jQuery always returns an Array for arguments, so need to look at first element\n                            // to determine whether multiple requests were made and consequently how to\n                            // map arguments to track definitions.\n                            var track_defs =\n                                arguments[0] instanceof Array\n                                    ? $.map(arguments, function(arg) {\n                                          return arg[0];\n                                      })\n                                    : [arguments[0]];\n                            success_fn(track_defs);\n                        });\n                        Galaxy.modal.hide();\n                    }\n                }\n            });\n        };\n\n        // --------- Models ---------\n\n        /**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\n        var CanvasManager = function(default_font) {\n            this.default_font = default_font !== undefined ? default_font : \"9px Monaco, Lucida Console, monospace\";\n\n            this.dummy_canvas = this.new_canvas();\n            this.dummy_context = this.dummy_canvas.getContext(\"2d\");\n            this.dummy_context.font = this.default_font;\n\n            this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n            this.patterns = {};\n\n            // FIXME: move somewhere to make this more general\n            this.load_pattern(\"right_strand\", \"/visualization/strand_right.png\");\n            this.load_pattern(\"left_strand\", \"/visualization/strand_left.png\");\n            this.load_pattern(\"right_strand_inv\", \"/visualization/strand_right_inv.png\");\n            this.load_pattern(\"left_strand_inv\", \"/visualization/strand_left_inv.png\");\n        };\n\n        _.extend(CanvasManager.prototype, {\n            load_pattern: function(key, path) {\n                var patterns = this.patterns,\n                    dummy_context = this.dummy_context,\n                    image = new Image();\n                image.src = Galaxy.root + \"static/images\" + path;\n                image.onload = function() {\n                    patterns[key] = dummy_context.createPattern(image, \"repeat\");\n                };\n            },\n            get_pattern: function(key) {\n                return this.patterns[key];\n            },\n            new_canvas: function() {\n                var canvas = $(\"<canvas/>\")[0];\n                // Keep a reference back to the manager\n                canvas.manager = this;\n                return canvas;\n            }\n        });\n\n        /**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\n        var Cache = Backbone.Model.extend({\n            defaults: {\n                num_elements: 20,\n                // Objects in cache; indexes into cache are strings of keys.\n                obj_cache: null,\n                // key_ary contains keys for objects in cache.\n                key_ary: null\n            },\n\n            initialize: function(options) {\n                this.clear();\n            },\n\n            /**\n     * Get an element from the cache using its key.\n     */\n            get_elt: function(key) {\n                var obj_cache = this.attributes.obj_cache,\n                    key_ary = this.attributes.key_ary,\n                    key_str = key.toString(),\n                    index = _.indexOf(key_ary, function(k) {\n                        return k.toString() === key_str;\n                    });\n\n                // Update cache.\n                if (index !== -1) {\n                    // Object is in cache, so update it.\n                    if (obj_cache[key_str].stale) {\n                        // Object is stale: remove key and object.\n                        key_ary.splice(index, 1);\n                        delete obj_cache[key_str];\n                    } else {\n                        // Move key to back because it is most recently used.\n                        this.move_key_to_end(key, index);\n                    }\n                }\n\n                return obj_cache[key_str];\n            },\n\n            /**\n     * Put an element into the cache.\n     */\n            set_elt: function(key, value) {\n                var obj_cache = this.attributes.obj_cache,\n                    key_ary = this.attributes.key_ary,\n                    key_str = key.toString(),\n                    num_elements = this.attributes.num_elements;\n\n                // Update keys, objects.\n                if (!obj_cache[key_str]) {\n                    // Add object to cache.\n\n                    if (key_ary.length >= num_elements) {\n                        // Cache full, so remove first element.\n                        var deleted_key = key_ary.shift();\n                        delete obj_cache[deleted_key.toString()];\n                    }\n\n                    // Add key.\n                    key_ary.push(key);\n                }\n\n                // Add object.\n                obj_cache[key_str] = value;\n                return value;\n            },\n\n            /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n            move_key_to_end: function(key, index) {\n                this.attributes.key_ary.splice(index, 1);\n                this.attributes.key_ary.push(key);\n            },\n\n            /**\n     * Clear all elements from the cache.\n     */\n            clear: function() {\n                this.attributes.obj_cache = {};\n                this.attributes.key_ary = [];\n            },\n\n            /** Returns the number of elements in the cache. */\n            size: function() {\n                return this.attributes.key_ary.length;\n            },\n\n            /** Returns key most recently added to cache. */\n            most_recently_added: function() {\n                return this.size() === 0\n                    ? null\n                    : // Most recent key is at the end of key array.\n                      this.attributes.key_ary[this.attributes.key_ary.length - 1];\n            }\n        });\n\n        /**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\n        var GenomeDataManager = Cache.extend({\n            defaults: _.extend({}, Cache.prototype.defaults, {\n                dataset: null,\n                genome: null,\n                init_data: null,\n                min_region_size: 200,\n                filters_manager: null,\n                data_type: \"data\",\n                data_mode_compatible: function(entry, mode) {\n                    return true;\n                },\n                can_subset: function(entry) {\n                    return false;\n                }\n            }),\n\n            /**\n     * Initialization.\n     */\n            initialize: function(options) {\n                Cache.prototype.initialize.call(this);\n\n                // Set initial entries in data manager.\n                var initial_entries = this.get(\"init_data\");\n                if (initial_entries) {\n                    this.add_data(initial_entries);\n                }\n            },\n\n            /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n            add_data: function(entries) {\n                // Increase size to accomodate all entries.\n                if (this.get(\"num_elements\") < entries.length) {\n                    this.set(\"num_elements\", entries.length);\n                }\n\n                // Put data into manager.\n                var self = this;\n                _.each(entries, function(entry) {\n                    self.set_data(entry.region, entry);\n                });\n            },\n\n            /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n            data_is_ready: function() {\n                var dataset = this.get(\"dataset\"),\n                    ready_deferred = $.Deferred(),\n                    // If requesting raw data, query dataset state; if requesting (converted) data,\n                    // need to query converted datasets state.\n                    query_type =\n                        this.get(\"data_type\") === \"raw_data\"\n                            ? \"state\"\n                            : this.get(\"data_type\") === \"data\" ? \"converted_datasets_state\" : \"error\",\n                    ss_deferred = new util_mod.ServerStateDeferred({\n                        ajax_settings: {\n                            url: this.get(\"dataset\").url(),\n                            data: {\n                                hda_ldda: dataset.get(\"hda_ldda\"),\n                                data_type: query_type\n                            },\n                            dataType: \"json\"\n                        },\n                        interval: 5000,\n                        success_fn: function(response) {\n                            return response !== \"pending\";\n                        }\n                    });\n\n                $.when(ss_deferred.go()).then(function(response) {\n                    ready_deferred.resolve(response === \"ok\" || response === \"data\");\n                });\n                return ready_deferred;\n            },\n\n            /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n            search_features: function(query) {\n                var dataset = this.get(\"dataset\"),\n                    params = {\n                        query: query,\n                        hda_ldda: dataset.get(\"hda_ldda\"),\n                        data_type: \"features\"\n                    };\n                return $.getJSON(dataset.url(), params);\n            },\n\n            /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n            load_data: function(region, mode, resolution, extra_params) {\n                // Setup data request params.\n                var dataset = this.get(\"dataset\"),\n                    params = {\n                        data_type: this.get(\"data_type\"),\n                        chrom: region.get(\"chrom\"),\n                        low: region.get(\"start\"),\n                        high: region.get(\"end\"),\n                        mode: mode,\n                        resolution: resolution,\n                        hda_ldda: dataset.get(\"hda_ldda\")\n                    };\n\n                $.extend(params, extra_params);\n\n                // Add track filters to params.\n                var filters_manager = this.get(\"filters_manager\");\n                if (filters_manager) {\n                    var filter_names = [];\n                    var filters = filters_manager.filters;\n                    for (var i = 0; i < filters.length; i++) {\n                        filter_names.push(filters[i].name);\n                    }\n                    params.filter_cols = JSON.stringify(filter_names);\n                }\n\n                // Do request.\n                var manager = this,\n                    entry = $.getJSON(dataset.url(), params, function(result) {\n                        // Add region to the result.\n                        result.region = region;\n                        manager.set_data(region, result);\n                    });\n\n                this.set_data(region, entry);\n                return entry;\n            },\n\n            /**\n     * Get data from dataset.\n     */\n            get_data: function(region, mode, resolution, extra_params) {\n                // Look for entry and return if it's a deferred or if data available is compatible with mode.\n                var entry = this.get_elt(region);\n                if (entry && (util_mod.is_deferred(entry) || this.get(\"data_mode_compatible\")(entry, mode))) {\n                    return entry;\n                }\n\n                //\n                // Look in cache for data that can be used.\n                // TODO: this logic could be improved if the visualization knew whether\n                // the data was \"index\" or \"data.\"\n                //\n                var key_ary = this.get(\"key_ary\"),\n                    obj_cache = this.get(\"obj_cache\"),\n                    entry_region,\n                    is_subregion;\n                for (var i = 0; i < key_ary.length; i++) {\n                    entry_region = key_ary[i];\n\n                    if (entry_region.contains(region)) {\n                        is_subregion = true;\n\n                        // This entry has data in the requested range. Return if data\n                        // is compatible and can be subsetted.\n                        entry = obj_cache[entry_region.toString()];\n                        if (\n                            util_mod.is_deferred(entry) ||\n                            (this.get(\"data_mode_compatible\")(entry, mode) && this.get(\"can_subset\")(entry))\n                        ) {\n                            this.move_key_to_end(entry_region, i);\n\n                            // If there's data, subset it.\n                            if (!util_mod.is_deferred(entry)) {\n                                var subset_entry = this.subset_entry(entry, region);\n                                this.set_data(region, subset_entry);\n                                entry = subset_entry;\n                            }\n\n                            return entry;\n                        }\n                    }\n                }\n\n                // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n                // subsetted. For these cases, do not increase length because region will never be found (and\n                // an infinite loop will occur.)\n                // If needed, extend region to make it minimum size.\n                if (!is_subregion && region.length() < this.attributes.min_region_size) {\n                    // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n                    // This would prevent bad extensions when zooming in/out while still preserving the behavior\n                    // below.\n\n                    // Use copy of region to avoid changing actual region.\n                    region = region.copy();\n\n                    // Use heuristic to extend region: extend relative to last data request.\n                    var last_request = this.most_recently_added();\n                    if (!last_request || region.get(\"start\") > last_request.get(\"start\")) {\n                        // This request is after the last request, so extend right.\n                        region.set(\"end\", region.get(\"start\") + this.attributes.min_region_size);\n                    } else {\n                        // This request is after the last request, so extend left.\n                        region.set(\"start\", region.get(\"end\") - this.attributes.min_region_size);\n                    }\n\n                    // Trim region to avoid invalid coordinates.\n                    region.set(\"genome\", this.attributes.genome);\n                    region.trim();\n                }\n\n                return this.load_data(region, mode, resolution, extra_params);\n            },\n\n            /**\n     * Alias for set_elt for readbility.\n     */\n            set_data: function(region, entry) {\n                this.set_elt(region, entry);\n            },\n\n            /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n            DEEP_DATA_REQ: \"deep\",\n\n            /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n            BROAD_DATA_REQ: \"breadth\",\n\n            /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n            get_more_data: function(region, mode, resolution, extra_params, req_type) {\n                var cur_data = this._mark_stale(region);\n                if (!(cur_data && this.get(\"data_mode_compatible\")(cur_data, mode))) {\n                    console.log(\"ERROR: problem with getting more data: current data is not compatible\");\n                    return;\n                }\n\n                //\n                // Set parameters based on request type.\n                //\n                var query_low = region.get(\"start\");\n                if (req_type === this.DEEP_DATA_REQ) {\n                    // Use same interval but set start_val to skip data that's already in cur_data.\n                    $.extend(extra_params, {\n                        start_val: cur_data.data.length + 1\n                    });\n                } else if (req_type === this.BROAD_DATA_REQ) {\n                    // To get past an area of extreme feature depth, set query low to be after either\n                    // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n                    query_low =\n                        (cur_data.max_high ? cur_data.max_high : cur_data.data[cur_data.data.length - 1][2]) + 1;\n                }\n                var query_region = region.copy().set(\"start\", query_low);\n\n                //\n                // Get additional data, append to current data, and set new data. Use a custom deferred object\n                // to signal when new data is available.\n                //\n                var data_manager = this,\n                    new_data_request = this.load_data(query_region, mode, resolution, extra_params),\n                    new_data_available = $.Deferred();\n                // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n                // is all data, not just new data.\n                this.set_data(region, new_data_available);\n                $.when(new_data_request).then(function(result) {\n                    // Update data and message.\n                    if (result.data) {\n                        result.data = cur_data.data.concat(result.data);\n                        if (result.max_low) {\n                            result.max_low = cur_data.max_low;\n                        }\n                        if (result.message) {\n                            // HACK: replace number in message with current data length. Works but is ugly.\n                            result.message = result.message.replace(/[0-9]+/, result.data.length);\n                        }\n                    }\n                    data_manager.set_data(region, result);\n                    new_data_available.resolve(result);\n                });\n                return new_data_available;\n            },\n\n            /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n            can_get_more_detailed_data: function(region) {\n                var cur_data = this.get_elt(region);\n\n                // Can only get more detailed data for bigwig data that has less than 8000 data points.\n                // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n                return cur_data.dataset_type === \"bigwig\" && cur_data.data.length < 8000;\n            },\n\n            /**\n     * Returns more detailed data for an entry.\n     */\n            get_more_detailed_data: function(region, mode, resolution, detail_multiplier, extra_params) {\n                // Mark current entry as stale.\n                var cur_data = this._mark_stale(region);\n                if (!cur_data) {\n                    console.log(\"ERROR getting more detailed data: no current data\");\n                    return;\n                }\n\n                if (!extra_params) {\n                    extra_params = {};\n                }\n\n                // Use additional parameters to get more detailed data.\n                if (cur_data.dataset_type === \"bigwig\") {\n                    // FIXME: constant should go somewhere.\n                    extra_params.num_samples = 1000 * detail_multiplier;\n                }\n\n                return this.load_data(region, mode, resolution, extra_params);\n            },\n\n            /**\n     * Marks cache data as stale.\n     */\n            _mark_stale: function(region) {\n                var entry = this.get_elt(region);\n                if (!entry) {\n                    console.log(\"ERROR: no data to mark as stale: \", this.get(\"dataset\"), region.toString());\n                }\n                entry.stale = true;\n                return entry;\n            },\n\n            /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n            get_genome_wide_data: function(genome) {\n                // -- Get all data. --\n\n                var self = this,\n                    all_data_available = true,\n                    //  Map chromosome info into genome data.\n                    gw_data = _.map(genome.get(\"chroms_info\").chrom_info, function(chrom_info) {\n                        var chrom_data = self.get_elt(\n                            new GenomeRegion({\n                                chrom: chrom_info.chrom,\n                                start: 0,\n                                end: chrom_info.len\n                            })\n                        );\n\n                        // Set flag if data is not available.\n                        if (!chrom_data) {\n                            all_data_available = false;\n                        }\n\n                        return chrom_data;\n                    });\n\n                // -- If all data is available, return it. --\n                if (all_data_available) {\n                    return gw_data;\n                }\n\n                // -- All data is not available, so load from server. --\n\n                var deferred = $.Deferred();\n                $.getJSON(this.get(\"dataset\").url(), { data_type: \"genome_data\" }, function(genome_wide_data) {\n                    self.add_data(genome_wide_data.data);\n                    deferred.resolve(genome_wide_data.data);\n                });\n\n                return deferred;\n            },\n\n            /**\n     * Returns entry with only data in the subregion.\n     */\n            subset_entry: function(entry, subregion) {\n                // Dictionary from entry type to function for subsetting data.\n                var subset_fns = {\n                    bigwig: function(data, subregion) {\n                        return _.filter(data, function(data_point) {\n                            return data_point[0] >= subregion.get(\"start\") && data_point[0] <= subregion.get(\"end\");\n                        });\n                    },\n                    refseq: function(data, subregion) {\n                        var seq_start = subregion.get(\"start\") - entry.region.get(\"start\");\n                        return entry.data.slice(seq_start, seq_start + subregion.length());\n                    }\n                };\n\n                // Subset entry if there is a function for subsetting and regions are not the same.\n                var subregion_data = entry.data;\n                if (!entry.region.same(subregion) && entry.dataset_type in subset_fns) {\n                    subregion_data = subset_fns[entry.dataset_type](entry.data, subregion);\n                }\n\n                // Return entry with subregion's data.\n                return {\n                    region: subregion,\n                    data: subregion_data,\n                    dataset_type: entry.dataset_type\n                };\n            }\n        });\n\n        var GenomeReferenceDataManager = GenomeDataManager.extend({\n            initialize: function(options) {\n                // Use generic object in place of dataset and set urlRoot to fetch data.\n                var dataset_placeholder = new Backbone.Model();\n                dataset_placeholder.urlRoot = options.data_url;\n                this.set(\"dataset\", dataset_placeholder);\n            },\n\n            load_data: function(region, mode, resolution, extra_params) {\n                // Fetch data if region is not too large.\n                return region.length() <= 100000\n                    ? GenomeDataManager.prototype.load_data.call(this, region, mode, resolution, extra_params)\n                    : { data: null, region: region };\n            }\n        });\n\n        /**\n * A genome build.\n */\n        var Genome = Backbone.Model.extend({\n            defaults: {\n                name: null,\n                key: null,\n                chroms_info: null\n            },\n\n            initialize: function(options) {\n                this.id = options.dbkey;\n            },\n\n            /**\n     * Shorthand for getting to chromosome information.\n     */\n            get_chroms_info: function() {\n                return this.attributes.chroms_info.chrom_info;\n            },\n\n            /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n            get_chrom_region: function(chr_name) {\n                // FIXME: use findWhere in underscore 1.4\n                var chrom_info = _.find(this.get_chroms_info(), function(chrom_info) {\n                    return chrom_info.chrom === chr_name;\n                });\n                return new GenomeRegion({\n                    chrom: chrom_info.chrom,\n                    end: chrom_info.len\n                });\n            },\n\n            /** Returns the length of a chromosome. */\n            get_chrom_len: function(chr_name) {\n                // FIXME: use findWhere in underscore 1.4\n                return _.find(this.get_chroms_info(), function(chrom_info) {\n                    return chrom_info.chrom === chr_name;\n                }).len;\n            }\n        });\n\n        /**\n * A genomic region.\n */\n        var GenomeRegion = Backbone.Model.extend(\n            {\n                defaults: {\n                    chrom: null,\n                    start: 0,\n                    end: 0,\n                    str_val: null,\n                    genome: null\n                },\n\n                /**\n     * Returns true if this region is the same as a given region.\n     * It does not test the genome right now.\n     */\n                same: function(region) {\n                    return (\n                        this.attributes.chrom === region.get(\"chrom\") &&\n                        this.attributes.start === region.get(\"start\") &&\n                        this.attributes.end === region.get(\"end\")\n                    );\n                },\n\n                /**\n     * If from_str specified, use it to initialize attributes.\n     */\n                initialize: function(options) {\n                    if (options.from_str) {\n                        var pieces = options.from_str.split(\":\"),\n                            chrom = pieces[0],\n                            start_end = pieces[1].split(\"-\");\n                        this.set({\n                            chrom: chrom,\n                            start: parseInt(start_end[0], 10),\n                            end: parseInt(start_end[1], 10)\n                        });\n                    }\n\n                    // Keep a copy of region's string value for fast lookup.\n                    this.attributes.str_val = this.get(\"chrom\") + \":\" + this.get(\"start\") + \"-\" + this.get(\"end\");\n\n                    // Set str_val on attribute change.\n                    this.on(\n                        \"change\",\n                        function() {\n                            this.attributes.str_val =\n                                this.get(\"chrom\") + \":\" + this.get(\"start\") + \"-\" + this.get(\"end\");\n                        },\n                        this\n                    );\n                },\n\n                copy: function() {\n                    return new GenomeRegion({\n                        chrom: this.get(\"chrom\"),\n                        start: this.get(\"start\"),\n                        end: this.get(\"end\")\n                    });\n                },\n\n                length: function() {\n                    return this.get(\"end\") - this.get(\"start\");\n                },\n\n                /** Returns region in canonical form chrom:start-end */\n                toString: function() {\n                    return this.attributes.str_val;\n                },\n\n                toJSON: function() {\n                    return {\n                        chrom: this.get(\"chrom\"),\n                        start: this.get(\"start\"),\n                        end: this.get(\"end\")\n                    };\n                },\n\n                /**\n     * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n     * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n     */\n                compute_overlap: function(a_region) {\n                    var first_chrom = this.get(\"chrom\"),\n                        second_chrom = a_region.get(\"chrom\"),\n                        first_start = this.get(\"start\"),\n                        second_start = a_region.get(\"start\"),\n                        first_end = this.get(\"end\"),\n                        second_end = a_region.get(\"end\"),\n                        overlap;\n\n                    // Compare chroms.\n                    if (first_chrom && second_chrom && first_chrom !== second_chrom) {\n                        return GenomeRegion.overlap_results.DIF_CHROMS;\n                    }\n\n                    // Compare regions.\n                    if (first_start < second_start) {\n                        if (first_end < second_start) {\n                            overlap = GenomeRegion.overlap_results.BEFORE;\n                        } else if (first_end < second_end) {\n                            overlap = GenomeRegion.overlap_results.OVERLAP_START;\n                        } else {\n                            // first_end >= second_end\n                            overlap = GenomeRegion.overlap_results.CONTAINS;\n                        }\n                    } else if (first_start > second_start) {\n                        if (first_start > second_end) {\n                            overlap = GenomeRegion.overlap_results.AFTER;\n                        } else if (first_end <= second_end) {\n                            overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n                        } else {\n                            overlap = GenomeRegion.overlap_results.OVERLAP_END;\n                        }\n                    } else {\n                        // first_start === second_start\n                        overlap =\n                            first_end >= second_end\n                                ? GenomeRegion.overlap_results.CONTAINS\n                                : GenomeRegion.overlap_results.CONTAINED_BY;\n                    }\n\n                    return overlap;\n                },\n\n                /**\n     * Trim a region to match genome's constraints.\n     */\n                trim: function(genome) {\n                    // Assume that all chromosome/contigs start at 0.\n                    if (this.attributes.start < 0) {\n                        this.attributes.start = 0;\n                    }\n\n                    // Only try to trim the end if genome is set.\n                    if (this.attributes.genome) {\n                        var chrom_len = this.attributes.genome.get_chrom_len(this.attributes.chrom);\n                        if (this.attributes.end > chrom_len) {\n                            this.attributes.end = chrom_len - 1;\n                        }\n                    }\n\n                    return this;\n                },\n\n                /**\n     * Returns true if this region contains a given region.\n     */\n                contains: function(a_region) {\n                    return this.compute_overlap(a_region) === GenomeRegion.overlap_results.CONTAINS;\n                },\n\n                /**\n     * Returns true if regions overlap.\n     */\n                overlaps: function(a_region) {\n                    return (\n                        _.intersection(\n                            [this.compute_overlap(a_region)],\n                            [\n                                GenomeRegion.overlap_results.DIF_CHROMS,\n                                GenomeRegion.overlap_results.BEFORE,\n                                GenomeRegion.overlap_results.AFTER\n                            ]\n                        ).length === 0\n                    );\n                }\n            },\n            {\n                overlap_results: {\n                    DIF_CHROMS: 1000,\n                    BEFORE: 1001,\n                    CONTAINS: 1002,\n                    OVERLAP_START: 1003,\n                    OVERLAP_END: 1004,\n                    CONTAINED_BY: 1005,\n                    AFTER: 1006\n                }\n            }\n        );\n\n        var GenomeRegionCollection = Backbone.Collection.extend({\n            model: GenomeRegion\n        });\n\n        /**\n * A genome browser bookmark.\n */\n        var BrowserBookmark = Backbone.Model.extend({\n            defaults: {\n                region: null,\n                note: \"\"\n            },\n\n            initialize: function(options) {\n                this.set(\"region\", new GenomeRegion(options.region));\n            }\n        });\n\n        /**\n * Bookmarks collection.\n */\n        var BrowserBookmarkCollection = Backbone.Collection.extend({\n            model: BrowserBookmark\n        });\n\n        /**\n * A track of data in a genome visualization.\n */\n        // TODO: rename to Track and merge with Trackster's Track object.\n        var BackboneTrack = Backbone.Model.extend(CustomToJSON).extend(\n            {\n                defaults: {\n                    mode: \"Auto\"\n                },\n\n                initialize: function(options) {\n                    this.set(\"dataset\", new data_mod.Dataset(options.dataset));\n\n                    // -- Set up config settings. --\n                    var models = [\n                        {\n                            key: \"name\",\n                            default_value: this.get(\"dataset\").get(\"name\")\n                        },\n                        { key: \"color\" },\n                        {\n                            key: \"min_value\",\n                            label: \"Min Value\",\n                            type: \"float\",\n                            default_value: 0\n                        },\n                        {\n                            key: \"max_value\",\n                            label: \"Max Value\",\n                            type: \"float\",\n                            default_value: 1\n                        }\n                    ];\n\n                    this.set(\n                        \"config\",\n                        config_mod.ConfigSettingCollection.from_models_and_saved_values(models, options.prefs)\n                    );\n\n                    // -- Set up data manager. --\n                    var preloaded_data = this.get(\"preloaded_data\");\n                    if (preloaded_data) {\n                        preloaded_data = preloaded_data.data;\n                    } else {\n                        preloaded_data = [];\n                    }\n                    this.set(\n                        \"data_manager\",\n                        new GenomeDataManager({\n                            dataset: this.get(\"dataset\"),\n                            init_data: preloaded_data\n                        })\n                    );\n                }\n            },\n            {\n                // This definition matches that produced by to_dict() methods in tracks.js\n                to_json_keys: [\"track_type\", \"dataset\", \"prefs\", \"mode\", \"filters\", \"tool_state\"],\n                to_json_mappers: {\n                    prefs: function(p, self) {\n                        if (_.size(p) === 0) {\n                            p = {\n                                name: self\n                                    .get(\"config\")\n                                    .get(\"name\")\n                                    .get(\"value\"),\n                                color: self\n                                    .get(\"config\")\n                                    .get(\"color\")\n                                    .get(\"value\")\n                            };\n                        }\n                        return p;\n                    },\n                    dataset: function(d) {\n                        return {\n                            id: d.id,\n                            hda_ldda: d.get(\"hda_ldda\")\n                        };\n                    }\n                }\n            }\n        );\n\n        var BackboneTrackCollection = Backbone.Collection.extend({\n            model: BackboneTrack\n        });\n\n        /**\n * A visualization.\n */\n        var Visualization = Backbone.Model.extend({\n            defaults: {\n                title: \"\",\n                type: \"\"\n            },\n\n            urlRoot: Galaxy.root + \"api/visualizations\",\n\n            /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n            save: function() {\n                return $.ajax({\n                    url: this.url(),\n                    type: \"POST\",\n                    dataType: \"json\",\n                    data: {\n                        vis_json: JSON.stringify(this)\n                    }\n                });\n            }\n        });\n\n        /**\n * A visualization of genome data.\n */\n        var GenomeVisualization = Visualization.extend(CustomToJSON).extend(\n            {\n                defaults: _.extend({}, Visualization.prototype.defaults, {\n                    dbkey: \"\",\n                    drawables: null,\n                    bookmarks: null,\n                    viewport: null\n                }),\n\n                initialize: function(options) {\n                    // Replace drawables with tracks.\n                    this.set(\"drawables\", new BackboneTrackCollection(options.tracks));\n\n                    var models = [];\n                    this.set(\n                        \"config\",\n                        config_mod.ConfigSettingCollection.from_models_and_saved_values(models, options.prefs)\n                    );\n\n                    // Clear track and data definitions to avoid storing large objects.\n                    this.unset(\"tracks\");\n                    this.get(\"drawables\").each(function(d) {\n                        d.unset(\"preloaded_data\");\n                    });\n                },\n\n                /**\n     * Add a track or array of tracks to the visualization.\n     */\n                add_tracks: function(tracks) {\n                    this.get(\"drawables\").add(tracks);\n                }\n            },\n            {\n                // This definition matches that produced by to_dict() methods in tracks.js\n                to_json_keys: [\"view\", \"viewport\", \"bookmarks\"],\n\n                to_json_mappers: {\n                    view: function(dummy, self) {\n                        return {\n                            obj_type: \"View\",\n                            prefs: {\n                                name: self.get(\"title\"),\n                                content_visible: true\n                            },\n                            drawables: self.get(\"drawables\")\n                        };\n                    }\n                }\n            }\n        );\n\n        /**\n * -- Routers --\n */\n\n        /**\n * Router for track browser.\n */\n        var TrackBrowserRouter = Backbone.Router.extend({\n            initialize: function(options) {\n                this.view = options.view;\n\n                // Can't put regular expression in routes dictionary.\n                // NOTE: parentheses are used to denote parameters returned to callback.\n                this.route(/([\\w]+)$/, \"change_location\");\n                this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, \"change_location\");\n\n                // Handle navigate events from view.\n                var self = this;\n                self.view.on(\"navigate\", function(new_loc) {\n                    self.navigate(new_loc);\n                });\n            },\n\n            change_location: function(new_loc) {\n                this.view.go_to(new_loc);\n            }\n        });\n\n        return {\n            BackboneTrack: BackboneTrack,\n            BrowserBookmark: BrowserBookmark,\n            BrowserBookmarkCollection: BrowserBookmarkCollection,\n            Cache: Cache,\n            CanvasManager: CanvasManager,\n            Genome: Genome,\n            GenomeDataManager: GenomeDataManager,\n            GenomeRegion: GenomeRegion,\n            GenomeRegionCollection: GenomeRegionCollection,\n            GenomeVisualization: GenomeVisualization,\n            GenomeReferenceDataManager: GenomeReferenceDataManager,\n            TrackBrowserRouter: TrackBrowserRouter,\n            Visualization: Visualization,\n            select_datasets: select_datasets\n        };\n    }\n);\n"]}