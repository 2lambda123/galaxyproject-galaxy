{"version":3,"sources":["viz/trackster/painters.js"],"names":["define","_","CONTAINED_BY","first_region","second_region","AFTER","compute_overlap","first_start","first_end","second_end","overlap","second_start","OVERLAP_END","OVERLAP_START","is_overlap","dashedLine","ctx","x1","y1","x2","y2","dashLen","undefined","dashX","dY","dX","floor","Math","sqrt","dashes","q","dashY","fillRect","drawDownwardEquilateralTriangle","down_vertex_x","down_vertex_y","side_len","beginPath","moveTo","y","lineTo","this","fillStyle","fill","strokeStyle","Scaler","default_val","prototype","gen_val","input","DrawResults","options","incomplete_features","Painter","data","view_start","view_end","prefs","mode","extend","default_prefs","draw","width","height","w_scale","get_start_draw_pos","chrom_pos","_chrom_pos_to_draw_pos","get_end_draw_pos","get_draw_pos","offset","max","LinePainter","call","min_value","max_value","in_path","vertical_range","height_px","y_zero","round","x_scaled","delta_x_pxs","slice","d","i","ceil","bot_overflow","painter_color","block_color","color","pref_r","pref_color","pref_g","parseInt","len","length","delta_x_px","top_overflow","new_r","saturation","new_b","pref_b","new_g","overflow_color","overflow_x","restore","FeaturePositionMapper","slot_height","feature_positions","translation","map_feature_data","feature_data","slot","x_start","x_end","get_feature_data","x","feature_dict","y_translation","FeaturePainter","alpha_scaler","height_scaler","max_label_length","connector_color","rows_required","required_height","get_row_height","get_required_height","y_scale","get_top_padding","slots","textAlign","feature_mapper","x_draw_coords","feature_start","feature","feature_end","feature_uid","draw_element","push","NO_DETAIL_TRACK_HEIGHT","tile_low","tile_high","SQUISH_TRACK_HEIGHT","LinkedFeaturePainter","draw_background_connector","draw_individual_connectors","DENSE_TRACK_HEIGHT","PACK_TRACK_HEIGHT","f_start","draw_start","draw_end","f_end","y_start","thickness","thick_start","thick_end","min","feature_strand","reverse_strand_color","label_color","feature_blocks","full_height","feature_te","thin_height","thick_height","SQUISH_FEATURE_HEIGHT","feature_ts","cur_height","cur_y_start","canvas","manager","get_pattern","k","k_len","last_block_start","last_block_end","block","block_start","block_end","block_thick_end","block_thick_start","globalAlpha","hscale_factor","new_height","ws_height","draw_connector","feature_name","measureText","fillText","ReadPainter","_parse_cigar","ref_seq","base_color_fn","parsed_cigar","cigar_str","cur_block","blocks","show_insertions","cigar_ops","draw_read","indexOf","cig_len","base_pos","map","match","op","op_len","cig_op","op_char","get_draw_coord","tile_region","base_offset","strand","paint_utils","drawing_blocks","cigar","read_seq","sequence_coord","s_start","s_end","gap","char_width_px","detail_block_color","pack_mode","draw_height","rect_y","cig","cig_id","ReadPainterUtils","draw_last","t","seq_offset","seq_start","cur_seq","start_pos","c","insert_x_coord","seq","c_start","type","CONNECTOR_COLOR","draw_deletion","str_len","x_center","connector","update_base_offset","update_seq_offset","item","save","font","b1_end","LABEL_SPACING","Array","ArcLinkedFeaturePainter","longest_feature_length","calculate_longest_feature_length","view_range","block1_end","angle1","b2_start","rgb","line_height","isArray","alpha","b","l","h","block1_start","block2_start","block2_end","s","radius","r","PI","stroke","Color","a","color1","p","w","toHSL","split","w1","eval","toCSS","start_value","end_value","map_value","value","concat","join","middle_color","LinearRamp","end_color","start_color","DiagonalHeatmapPainter","g","positive_ramp","negative_ramp","Infinity","toARGB","value_range","toString","invsqrt2","mix","color2","weight","w2","scale","s1","s2","px_per_base","draw_details","delete_details_thickness","SplitRamp","row_height","VariantPainter","pos_color","neg_color","num_samples","e1","e2","ramp","rotate","ref","start","qual","feature_height","alt","summary_height","indel_info","get_indel_info","divider_height","locus_data","pos","variant","sample_gts","allele_counts","ref_len","j","draw_y_start","alt_len","base_px","draw_x_start","draw_summary","show_sample_data","flatten","alt_info","allele_frac","genotype","snp"],"mappings":"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","file":"../../../scripts/viz/trackster/painters.js","sourcesContent":["define([\"libs/underscore\"], function(_) {\n    /**\n * Compute the type of overlap between two regions. They are assumed to be on the same chrom/contig.\n * The overlap is computed relative to the second region; hence, OVERLAP_START indicates that the first\n * region overlaps the start (but not the end) of the second region.\n * NOTE: Coordinates are assumed to be in BED format: half open (start is closed, end is open).\n */\n    var BEFORE = 1001,\n        CONTAINS = 1002,\n        OVERLAP_START = 1003,\n        OVERLAP_END = 1004,\n        CONTAINED_BY = 1005,\n        AFTER = 1006;\n    var compute_overlap = function(first_region, second_region) {\n        var first_start = first_region[0],\n            first_end = first_region[1],\n            second_start = second_region[0],\n            second_end = second_region[1],\n            overlap;\n        if (first_start < second_start) {\n            if (first_end <= second_start) {\n                overlap = BEFORE;\n            } else if (first_end <= second_end) {\n                overlap = OVERLAP_START;\n            } else {\n                // first_end > second_end\n                overlap = CONTAINS;\n            }\n        } else {\n            // first_start >= second_start\n            if (first_start > second_end) {\n                overlap = AFTER;\n            } else if (first_end <= second_end) {\n                overlap = CONTAINED_BY;\n            } else {\n                overlap = OVERLAP_END;\n            }\n        }\n\n        return overlap;\n    };\n\n    /**\n * Returns true if regions overlap.\n */\n    var is_overlap = function(first_region, second_region) {\n        var overlap = compute_overlap(first_region, second_region);\n        return overlap !== BEFORE && overlap !== AFTER;\n    };\n\n    /**\n * Draw a dashed line on a canvas using filled rectangles. This function is based on:\n * http://vetruvet.blogspot.com/2010/10/drawing-dashed-lines-on-html5-canvas.html\n * However, that approach uses lines, which don't seem to render as well, so use\n * rectangles instead.\n */\n    var dashedLine = function(ctx, x1, y1, x2, y2, dashLen) {\n        if (dashLen === undefined) {\n            dashLen = 4;\n        }\n        var dX = x2 - x1;\n        var dY = y2 - y1;\n        var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\n        var dashX = dX / dashes;\n        var dashY = dY / dashes;\n        var q;\n\n        for (q = 0; q < dashes; q++, x1 += dashX, y1 += dashY) {\n            if (q % 2 !== 0) {\n                continue;\n            }\n            ctx.fillRect(x1, y1, dashLen, 1);\n        }\n    };\n\n    /**\n * Draw an isosceles triangle that points down.\n */\n    var drawDownwardEquilateralTriangle = function(ctx, down_vertex_x, down_vertex_y, side_len) {\n        // Compute other two points of triangle.\n        var x1 = down_vertex_x - side_len / 2,\n            x2 = down_vertex_x + side_len / 2,\n            y = down_vertex_y - Math.sqrt(side_len * 3 / 2);\n\n        // Draw and fill.\n        ctx.beginPath();\n        ctx.moveTo(x1, y);\n        ctx.lineTo(x2, y);\n        ctx.lineTo(down_vertex_x, down_vertex_y);\n        ctx.lineTo(x1, y);\n\n        ctx.strokeStyle = this.fillStyle;\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n    };\n\n    /**\n * Base class for all scalers. Scalers produce values that are used to change (scale) drawing attributes.\n */\n    var Scaler = function(default_val) {\n        this.default_val = default_val ? default_val : 1;\n    };\n\n    /**\n * Produce a scaling value.\n */\n    Scaler.prototype.gen_val = function(input) {\n        return this.default_val;\n    };\n\n    /**\n * Results from painter.draw()\n */\n    var DrawResults = function(options) {\n        this.incomplete_features = options.incomplete_features;\n        this.feature_mapper = options.feature_mapper;\n    };\n\n    /**\n * Base class for painters\n *\n * -- Mode and prefs are both optional\n */\n    var Painter = function(data, view_start, view_end, prefs, mode) {\n        // Data and data properties\n        this.data = data;\n        // View\n        this.view_start = view_start;\n        this.view_end = view_end;\n        // Drawing prefs\n        this.prefs = _.extend({}, this.default_prefs, prefs);\n        this.mode = mode;\n    };\n\n    Painter.prototype.default_prefs = {};\n\n    /**\n * Draw on the context using a rectangle of width x height using scale w_scale.\n */\n    Painter.prototype.draw = function(ctx, width, height, w_scale) {};\n\n    /**\n * Get starting drawing position, which is offset a half-base left of coordinate.\n */\n    Painter.prototype.get_start_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, -0.5);\n    };\n\n    /**\n * Get end drawing position, which is offset a half-base right of coordinate.\n */\n    Painter.prototype.get_end_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0.5);\n    };\n\n    /**\n * Get drawing position.\n */\n    Painter.prototype.get_draw_pos = function(chrom_pos, w_scale) {\n        return this._chrom_pos_to_draw_pos(chrom_pos, w_scale, 0);\n    };\n\n    /**\n * Convert chromosome position to drawing position.\n */\n    Painter.prototype._chrom_pos_to_draw_pos = function(chrom_pos, w_scale, offset) {\n        return Math.floor(w_scale * (Math.max(0, chrom_pos - this.view_start) + offset));\n    };\n\n    var LinePainter = function(data, view_start, view_end, prefs, mode) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n    };\n\n    LinePainter.prototype.default_prefs = {\n        min_value: undefined,\n        max_value: undefined,\n        mode: \"Histogram\",\n        color: \"#000\",\n        overflow_color: \"#F66\"\n    };\n\n    LinePainter.prototype.draw = function(ctx, width, height, w_scale) {\n        var in_path = false,\n            min_value = this.prefs.min_value,\n            max_value = this.prefs.max_value,\n            vertical_range = max_value - min_value,\n            height_px = height,\n            view_start = this.view_start,\n            mode = this.mode,\n            data = this.data;\n\n        ctx.save();\n\n        // Pixel position of 0 on the y axis\n        var y_zero = Math.round(height + min_value / vertical_range * height);\n\n        // Horizontal line to denote x-axis\n        if (mode !== \"Intensity\") {\n            ctx.fillStyle = \"#aaa\";\n            ctx.fillRect(0, y_zero, width, 1);\n        }\n\n        ctx.beginPath();\n        var x_scaled, y, delta_x_pxs;\n        if (data.length > 1) {\n            delta_x_pxs = _.map(data.slice(0, -1), function(d, i) {\n                return Math.ceil((data[i + 1][0] - data[i][0]) * w_scale);\n            });\n        } else {\n            delta_x_pxs = [10];\n        }\n\n        // Painter color can be in either block_color (FeatureTrack) or color pref (LineTrack).\n        var painter_color = this.prefs.block_color || this.prefs.color,\n            // Extract RGB from preference color.\n            pref_color = parseInt(painter_color.slice(1), 16),\n            pref_r = (pref_color & 0xff0000) >> 16,\n            pref_g = (pref_color & 0x00ff00) >> 8,\n            pref_b = pref_color & 0x0000ff,\n            top_overflow = false,\n            bot_overflow = false;\n\n        // Paint track.\n        var delta_x_px;\n        for (var i = 0, len = data.length; i < len; i++) {\n            // Reset attributes for next point.\n            ctx.fillStyle = ctx.strokeStyle = painter_color;\n            top_overflow = bot_overflow = false;\n            delta_x_px = delta_x_pxs[i];\n\n            x_scaled = Math.floor((data[i][0] - view_start - 0.5) * w_scale);\n            y = data[i][1];\n\n            // Process Y (scaler) value.\n            if (y === null) {\n                if (in_path && mode === \"Filled\") {\n                    ctx.lineTo(x_scaled, height_px);\n                }\n                in_path = false;\n                continue;\n            }\n\n            // Bound Y value by min, max.\n            if (y < min_value) {\n                bot_overflow = true;\n                y = min_value;\n            } else if (y > max_value) {\n                top_overflow = true;\n                y = max_value;\n            }\n\n            // Draw point.\n            if (mode === \"Histogram\") {\n                // y becomes the bar height in pixels, which is the negated for canvas coords\n                y = Math.round(y / vertical_range * height_px);\n                ctx.fillRect(x_scaled, y_zero, delta_x_px, -y);\n            } else if (mode === \"Intensity\") {\n                var saturation = (y - min_value) / vertical_range,\n                    // Range is [pref_color, 255] where saturation = 0 --> 255 and saturation = 1 --> pref color\n                    new_r = Math.round(pref_r + (255 - pref_r) * (1 - saturation)),\n                    new_g = Math.round(pref_g + (255 - pref_g) * (1 - saturation)),\n                    new_b = Math.round(pref_b + (255 - pref_b) * (1 - saturation));\n                ctx.fillStyle = \"rgb(\" + new_r + \",\" + new_g + \",\" + new_b + \")\";\n                ctx.fillRect(x_scaled, 0, delta_x_px, height_px);\n            } else {\n                // mode is Coverage/Line or Filled.\n\n                // Scale Y value.\n                y = Math.round(height_px - (y - min_value) / vertical_range * height_px);\n                if (in_path) {\n                    ctx.lineTo(x_scaled, y);\n                } else {\n                    in_path = true;\n                    if (mode === \"Filled\") {\n                        ctx.moveTo(x_scaled, height_px);\n                        ctx.lineTo(x_scaled, y);\n                    } else {\n                        ctx.moveTo(x_scaled, y);\n                        // Use this approach (note: same as for filled) to draw line from 0 to\n                        // first data point.\n                        //ctx.moveTo(x_scaled, height_px);\n                        //ctx.lineTo(x_scaled, y);\n                    }\n                }\n            }\n\n            // Draw lines at boundaries if overflowing min or max\n            ctx.fillStyle = this.prefs.overflow_color;\n            if (top_overflow || bot_overflow) {\n                var overflow_x;\n                if (mode === \"Histogram\" || mode === \"Intensity\") {\n                    overflow_x = delta_x_px;\n                } else {\n                    // Line and Filled, which are points\n                    x_scaled -= 2; // Move it over to the left so it's centered on the point\n                    overflow_x = 4;\n                }\n                if (top_overflow) {\n                    ctx.fillRect(x_scaled, 0, overflow_x, 3);\n                }\n                if (bot_overflow) {\n                    ctx.fillRect(x_scaled, height_px - 3, overflow_x, 3);\n                }\n            }\n            ctx.fillStyle = painter_color;\n        }\n        if (mode === \"Filled\") {\n            if (in_path) {\n                ctx.lineTo(x_scaled, y_zero);\n                ctx.lineTo(0, y_zero);\n            }\n            ctx.fill();\n        } else {\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    };\n\n    /**\n * Mapper that contains information about feature locations and data.\n */\n    var FeaturePositionMapper = function(slot_height) {\n        this.feature_positions = {};\n        this.slot_height = slot_height;\n        this.translation = 0;\n        this.y_translation = 0;\n    };\n\n    /**\n * Map feature data to a position defined by <slot, x_start, x_end>.\n */\n    FeaturePositionMapper.prototype.map_feature_data = function(feature_data, slot, x_start, x_end) {\n        if (!this.feature_positions[slot]) {\n            this.feature_positions[slot] = [];\n        }\n        this.feature_positions[slot].push({\n            data: feature_data,\n            x_start: x_start,\n            x_end: x_end\n        });\n    };\n\n    /**\n * Get feature data for position <x, y>\n */\n    FeaturePositionMapper.prototype.get_feature_data = function(x, y) {\n        // Find slot using Y.\n        var slot = Math.floor((y - this.y_translation) / this.slot_height),\n            feature_dict;\n\n        // May not be over a slot due to padding, margin, etc.\n        if (!this.feature_positions[slot]) {\n            return null;\n        }\n\n        // Find feature using X.\n        x += this.translation;\n        for (var i = 0; i < this.feature_positions[slot].length; i++) {\n            feature_dict = this.feature_positions[slot][i];\n            if (x >= feature_dict.x_start && x <= feature_dict.x_end) {\n                return feature_dict.data;\n            }\n        }\n    };\n\n    /**\n * Abstract object for painting feature tracks. Subclasses must implement draw_element() for painting to work.\n * Painter uses a 0-based, half-open coordinate system; start coordinate is closed--included--and the end is open.\n * This coordinate system matches the BED format.\n */\n    var FeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        this.alpha_scaler = alpha_scaler ? alpha_scaler : new Scaler();\n        this.height_scaler = height_scaler ? height_scaler : new Scaler();\n        this.max_label_length = 200;\n    };\n\n    FeaturePainter.prototype.default_prefs = {\n        block_color: \"#FFF\",\n        connector_color: \"#FFF\"\n    };\n\n    _.extend(FeaturePainter.prototype, {\n        get_required_height: function(rows_required, width) {\n            // y_scale is the height per row\n            var required_height = this.get_row_height(),\n                y_scale = required_height,\n                mode = this.mode;\n            // If using a packing mode, need to multiply by the number of slots used\n            if (mode === \"no_detail\" || mode === \"Squish\" || mode === \"Pack\") {\n                required_height = rows_required * y_scale;\n            }\n            return required_height + this.get_top_padding(width);\n        },\n\n        /** Extra padding before first row of features */\n        get_top_padding: function(width) {\n            return 0;\n        },\n\n        /**\n     * Draw data on ctx using slots and within the rectangle defined by width and height. Returns\n     * a FeaturePositionMapper object with information about where features were drawn.\n     */\n        draw: function(ctx, width, height, w_scale, slots) {\n            var data = this.data,\n                view_start = this.view_start,\n                view_end = this.view_end;\n\n            ctx.save();\n\n            ctx.fillStyle = this.prefs.block_color;\n            ctx.textAlign = \"right\";\n\n            var y_scale = this.get_row_height(),\n                feature_mapper = new FeaturePositionMapper(y_scale),\n                x_draw_coords,\n                incomplete_features = [];\n\n            for (var i = 0, len = data.length; i < len; i++) {\n                var feature = data[i],\n                    feature_uid = feature[0],\n                    feature_start = feature[1],\n                    feature_end = feature[2],\n                    // Slot valid only if features are slotted and this feature is slotted;\n                    // feature may not be due to lack of space.\n                    slot = slots && slots[feature_uid] !== undefined ? slots[feature_uid].slot : null;\n\n                // Draw feature if (a) mode is dense or feature is slotted (as it must be for all non-dense modes) and\n                // (b) there's overlap between the feature and drawing region.\n                if (\n                    (this.mode === \"Dense\" || slot !== null) &&\n                    (feature_start < view_end && feature_end > view_start)\n                ) {\n                    x_draw_coords = this.draw_element(\n                        ctx,\n                        this.mode,\n                        feature,\n                        slot,\n                        view_start,\n                        view_end,\n                        w_scale,\n                        y_scale,\n                        width\n                    );\n                    feature_mapper.map_feature_data(feature, slot, x_draw_coords[0], x_draw_coords[1]);\n\n                    // Add to incomplete features if it's not drawn completely in region.\n                    if (feature_start < view_start || feature_end > view_end) {\n                        incomplete_features.push(feature);\n                    }\n                }\n            }\n\n            ctx.restore();\n\n            feature_mapper.y_translation = this.get_top_padding(width);\n            return new DrawResults({\n                incomplete_features: incomplete_features,\n                feature_mapper: feature_mapper\n            });\n        },\n\n        /**\n     * Abstract function for drawing an individual feature.\n     */\n        draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n            return [0, 0];\n        }\n    });\n\n    // Constants specific to feature tracks moved here (HACKING, these should\n    // basically all be configuration options)\n    var DENSE_TRACK_HEIGHT = 10,\n        NO_DETAIL_TRACK_HEIGHT = 3,\n        SQUISH_TRACK_HEIGHT = 5,\n        PACK_TRACK_HEIGHT = 10,\n        NO_DETAIL_FEATURE_HEIGHT = 1,\n        DENSE_FEATURE_HEIGHT = 9,\n        SQUISH_FEATURE_HEIGHT = 3,\n        PACK_FEATURE_HEIGHT = 9,\n        LABEL_SPACING = 2,\n        CONNECTOR_COLOR = \"#ccc\";\n\n    var LinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        // Whether to draw a single connector in the background that spans the entire feature (the intron fishbone)\n        this.draw_background_connector = true;\n        // Whether to call draw_connector for every pair of blocks\n        this.draw_individual_connectors = false;\n    };\n\n    _.extend(LinkedFeaturePainter.prototype, FeaturePainter.prototype, {\n        /**\n     * Height of a single row, depends on mode\n     */\n        get_row_height: function() {\n            var mode = this.mode,\n                height;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"no_detail\") {\n                height = NO_DETAIL_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n            }\n            return height;\n        },\n\n        /**\n     * Draw a feature. Returns an array with feature's start and end X coordinates.\n     */\n        draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n            var feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                feature_name = feature[3],\n                feature_strand = feature[4],\n                // -0.5 to offset region between bases.\n                f_start = Math.floor(Math.max(0, (feature_start - tile_low - 0.5) * w_scale)),\n                f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale))),\n                draw_start = f_start,\n                draw_end = f_end,\n                y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale + this.get_top_padding(width),\n                thickness,\n                y_start,\n                thick_start = null,\n                thick_end = null,\n                // TODO: is there any reason why block, label color cannot be set at the Painter level?\n                // For now, assume '.' === '+'\n                block_color =\n                    !feature_strand || feature_strand === \"+\" || feature_strand === \".\"\n                        ? this.prefs.block_color\n                        : this.prefs.reverse_strand_color,\n                label_color = this.prefs.label_color;\n\n            // Set global alpha.\n            ctx.globalAlpha = this.alpha_scaler.gen_val(feature);\n\n            // In dense mode, put all data in top slot.\n            if (mode === \"Dense\") {\n                slot = 1;\n            }\n\n            if (mode === \"no_detail\") {\n                // No details for feature, so only one way to display.\n                ctx.fillStyle = block_color;\n                ctx.fillRect(f_start, y_start + 5, f_end - f_start, NO_DETAIL_FEATURE_HEIGHT);\n            } else {\n                // Mode is either Squish or Pack:\n                // Feature details.\n                var feature_ts = feature[5],\n                    feature_te = feature[6],\n                    feature_blocks = feature[7],\n                    // Whether we are drawing full height or squished features\n                    full_height = true;\n\n                if (feature_ts && feature_te) {\n                    thick_start = Math.floor(Math.max(0, (feature_ts - tile_low) * w_scale));\n                    thick_end = Math.ceil(Math.min(width, Math.max(0, (feature_te - tile_low) * w_scale)));\n                }\n\n                // Set vars that depend on mode.\n                var thin_height, thick_height;\n                if (mode === \"Squish\") {\n                    thin_height = 1;\n                    thick_height = SQUISH_FEATURE_HEIGHT;\n                    full_height = false;\n                } else if (mode === \"Dense\") {\n                    thin_height = 5;\n                    thick_height = DENSE_FEATURE_HEIGHT;\n                } else {\n                    // mode === \"Pack\"\n                    thin_height = 5;\n                    thick_height = PACK_FEATURE_HEIGHT;\n                }\n\n                // Draw feature/feature blocks + connectors.\n                if (!feature_blocks) {\n                    // If there are no blocks, treat the feature as one big exon.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                    // If strand is specified, draw arrows over feature\n                    if (feature_strand && full_height) {\n                        if (feature_strand === \"+\") {\n                            ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                        } else if (feature_strand === \"-\") {\n                            ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                        }\n                        ctx.fillRect(f_start, y_start + 1, f_end - f_start, thick_height);\n                    }\n                } else {\n                    //\n                    // There are feature blocks and mode is either Squish or Pack.\n                    //\n                    // Approach: (a) draw whole feature as connector/intron and (b) draw blocks as\n                    // needed. This ensures that whole feature, regardless of whether it starts with\n                    // a block, is visible.\n                    //\n\n                    // Compute y axis start position and height\n                    var cur_y_start, cur_height;\n                    if (mode === \"Squish\" || mode === \"Dense\") {\n                        cur_y_start = y_start + Math.floor(SQUISH_FEATURE_HEIGHT / 2) + 1;\n                        cur_height = 1;\n                    } else {\n                        // mode === \"Pack\"\n                        if (feature_strand) {\n                            cur_y_start = y_start;\n                            cur_height = thick_height;\n                        } else {\n                            cur_y_start += SQUISH_FEATURE_HEIGHT / 2 + 1;\n                            cur_height = 1;\n                        }\n                    }\n\n                    // Draw whole feature as connector/intron.\n                    if (this.draw_background_connector) {\n                        if (mode === \"Squish\" || mode === \"Dense\") {\n                            ctx.fillStyle = CONNECTOR_COLOR;\n                        } else {\n                            // mode === \"Pack\"\n                            if (feature_strand) {\n                                if (feature_strand === \"+\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand\");\n                                } else if (feature_strand === \"-\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand\");\n                                }\n                            } else {\n                                ctx.fillStyle = CONNECTOR_COLOR;\n                            }\n                        }\n                        ctx.fillRect(f_start, cur_y_start, f_end - f_start, cur_height);\n                    }\n\n                    // Draw blocks.\n                    var start_and_height;\n                    for (var k = 0, k_len = feature_blocks.length; k < k_len; k++) {\n                        var block = feature_blocks[k],\n                            // -0.5 to offset block between bases.\n                            block_start = Math.floor(Math.max(0, (block[0] - tile_low - 0.5) * w_scale)),\n                            block_end = Math.ceil(Math.min(width, Math.max((block[1] - tile_low - 0.5) * w_scale))),\n                            last_block_start,\n                            last_block_end;\n\n                        // Skip drawing if block not on tile.\n                        if (block_start > block_end) {\n                            continue;\n                        }\n\n                        // Draw thin block.\n                        ctx.fillStyle = block_color;\n                        ctx.fillRect(\n                            block_start,\n                            y_start + (thick_height - thin_height) / 2 + 1,\n                            block_end - block_start,\n                            thin_height\n                        );\n\n                        // If block intersects with thick region, draw block as thick.\n                        // - No thick is sometimes encoded as thick_start == thick_end, so don't draw in that case\n                        if (\n                            thick_start !== undefined &&\n                            feature_te > feature_ts &&\n                            !(block_start > thick_end || block_end < thick_start)\n                        ) {\n                            var block_thick_start = Math.max(block_start, thick_start),\n                                block_thick_end = Math.min(block_end, thick_end);\n                            ctx.fillRect(\n                                block_thick_start,\n                                y_start + 1,\n                                block_thick_end - block_thick_start,\n                                thick_height\n                            );\n                            if (feature_blocks.length === 1 && mode === \"Pack\") {\n                                // Exactly one block means we have no introns, but do have a distinct \"thick\" region,\n                                // draw arrows over it if in pack mode.\n                                if (feature_strand === \"+\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\"right_strand_inv\");\n                                } else if (feature_strand === \"-\") {\n                                    ctx.fillStyle = ctx.canvas.manager.get_pattern(\"left_strand_inv\");\n                                }\n                                // If region is wide enough in pixels, pad a bit\n                                if (block_thick_start + 14 < block_thick_end) {\n                                    block_thick_start += 2;\n                                    block_thick_end -= 2;\n                                }\n                                ctx.fillRect(\n                                    block_thick_start,\n                                    y_start + 1,\n                                    block_thick_end - block_thick_start,\n                                    thick_height\n                                );\n                            }\n                        }\n                        // Draw individual connectors if required\n                        if (this.draw_individual_connectors && last_block_start) {\n                            this.draw_connector(ctx, last_block_start, last_block_end, block_start, block_end, y_start);\n                        }\n                        last_block_start = block_start;\n                        last_block_end = block_end;\n                    }\n\n                    // FIXME: Height scaling only works in Pack mode right now.\n                    if (mode === \"Pack\") {\n                        // Reset alpha so height scaling is not impacted by alpha scaling.\n                        ctx.globalAlpha = 1;\n\n                        // Height scaling: draw white lines to reduce height according to height scale factor.\n                        ctx.fillStyle = \"white\"; // TODO: set this to background color.\n                        var hscale_factor = this.height_scaler.gen_val(feature),\n                            // Ceil ensures that min height is >= 1.\n                            new_height = Math.ceil(thick_height * hscale_factor),\n                            ws_height = Math.round((thick_height - new_height) / 2);\n                        if (hscale_factor !== 1) {\n                            ctx.fillRect(f_start, cur_y_start + 1, f_end - f_start, ws_height);\n                            ctx.fillRect(\n                                f_start,\n                                cur_y_start + thick_height - ws_height + 1,\n                                f_end - f_start,\n                                ws_height\n                            );\n                        }\n                    }\n                }\n\n                // Reset alpha so that label is not transparent.\n                ctx.globalAlpha = 1;\n\n                // Draw label for Pack mode.\n                if (feature_name && mode === \"Pack\" && feature_start > tile_low) {\n                    ctx.fillStyle = label_color;\n                    // FIXME: assumption here that the entire view starts at 0\n                    if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                        ctx.textAlign = \"left\";\n                        ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 8, this.max_label_length);\n                        draw_end += ctx.measureText(feature_name).width + LABEL_SPACING;\n                    } else {\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 8, this.max_label_length);\n                        draw_start -= ctx.measureText(feature_name).width + LABEL_SPACING;\n                    }\n                    //ctx.fillStyle = block_color;\n                }\n            }\n\n            // Reset global alpha.\n            ctx.globalAlpha = 1;\n\n            return [draw_start, draw_end];\n        }\n    });\n\n    var ReadPainter = function(\n        data,\n        view_start,\n        view_end,\n        prefs,\n        mode,\n        alpha_scaler,\n        height_scaler,\n        ref_seq,\n        base_color_fn\n    ) {\n        FeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        this.ref_seq = ref_seq ? ref_seq.data : null;\n        this.base_color_fn = base_color_fn;\n    };\n\n    _.extend(ReadPainter.prototype, FeaturePainter.prototype, {\n        /**\n     * Returns height based on mode.\n     */\n        get_row_height: function() {\n            var height,\n                mode = this.mode;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n                if (this.prefs.show_insertions) {\n                    height *= 2;\n                }\n            }\n            return height;\n        },\n\n        /**\n     * Parse CIGAR string to get (a) a list of contiguous drawing blocks (MD=X) and\n     * (b) an array of [ op_index, op_len ] pairs where op_index is an index into the\n     * string 'MIDNSHP=X' Return value is a dictionary with two entries, blocks and cigar\n     */\n        _parse_cigar: function(cigar_str) {\n            var cigar_ops = \"MIDNSHP=X\";\n\n            // Parse cigar.\n            var blocks = [[0, 0]],\n                cur_block = blocks[0],\n                base_pos = 0,\n                // Parse cigar operations out and update/create blocks as needed.\n                parsed_cigar = _.map(cigar_str.match(/[0-9]+[MIDNSHP=X]/g), function(op) {\n                    // Get operation length, character.\n                    var op_len = parseInt(op.slice(0, -1), 10),\n                        op_char = op.slice(-1);\n\n                    // Update drawing block.\n                    if (op_char === \"N\") {\n                        // At skip, so need to start new block if current block represents\n                        // drawing area.\n                        if (cur_block[1] !== 0) {\n                            cur_block = [base_pos + op_len, base_pos + op_len];\n                            blocks.push(cur_block);\n                        }\n                    } else if (\"ISHP\".indexOf(op_char) === -1) {\n                        // Operation is M,D,=,X.\n                        cur_block[1] += op_len;\n                        base_pos += op_len;\n                    }\n\n                    // Return parsed cigar.\n                    return [cigar_ops.indexOf(op_char), op_len];\n                });\n\n            return {\n                blocks: blocks,\n                cigar: parsed_cigar\n            };\n        },\n\n        /**\n     * Draw a single read from reference-based read sequence and cigar.\n     */\n        draw_read: function(ctx, mode, w_scale, y_start, tile_low, tile_high, feature_start, cigar, strand, read_seq) {\n            // Helper function to update base and sequnence offsets.\n            var update_base_offset = function(offset, cig_op, cig_len) {\n                    if (\"M=NXD\".indexOf(cig_op) !== -1) {\n                        offset += cig_len;\n                    }\n                    return offset;\n                },\n                update_seq_offset = function(offset, cig_op, cig_len) {\n                    if (\"IX\".indexOf(cig_op) !== -1) {\n                        offset += cig_len;\n                    }\n                    return offset;\n                },\n                // Gets drawing coordinate for a sequence coordinate. Assumes closure variables w_scale and tile_low.\n                get_draw_coord = function(sequence_coord) {\n                    // -0.5 to offset sequence between bases.\n                    return Math.floor(Math.max(0, (sequence_coord - tile_low - 0.5) * w_scale));\n                };\n\n            ctx.textAlign = \"center\";\n            var tile_region = [tile_low, tile_high],\n                base_offset = 0,\n                seq_offset = 0,\n                gap = Math.round(w_scale / 2),\n                char_width_px = ctx.canvas.manager.char_width_px,\n                block_color = strand === \"+\" ? this.prefs.detail_block_color : this.prefs.reverse_strand_color,\n                pack_mode = mode === \"Pack\",\n                draw_height = pack_mode ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT,\n                rect_y = y_start + 1,\n                paint_utils = new ReadPainterUtils(ctx, draw_height, w_scale, mode),\n                drawing_blocks = [],\n                s_start,\n                s_end;\n\n            // Keep list of items that need to be drawn on top of initial drawing layer.\n            var draw_last = [];\n\n            // Parse cigar and get drawing blocks.\n            var t = this._parse_cigar(cigar);\n            cigar = t.cigar;\n            drawing_blocks = t.blocks;\n\n            // Draw blocks.\n            for (var i = 0; i < drawing_blocks.length; i++) {\n                var block = drawing_blocks[i];\n\n                if (is_overlap([feature_start + block[0], feature_start + block[1]], tile_region)) {\n                    s_start = get_draw_coord(feature_start + block[0]);\n                    s_end = get_draw_coord(feature_start + block[1]);\n\n                    // Make sure that block is drawn even if it too small to be rendered officially; in this case,\n                    // read is drawn at 1px.\n                    // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                    // and drawing.\n                    if (s_start === s_end) {\n                        s_end += 1;\n                    }\n\n                    // Draw read base as rectangle.\n                    ctx.fillStyle = block_color;\n                    ctx.fillRect(s_start, rect_y, s_end - s_start, draw_height);\n                }\n            }\n\n            // Draw read features.\n            for (var cig_id = 0, len = cigar.length; cig_id < len; cig_id++) {\n                var cig = cigar[cig_id],\n                    cig_op = \"MIDNSHP=X\"[cig[0]],\n                    cig_len = cig[1];\n\n                var seq_start = feature_start + base_offset;\n                s_start = get_draw_coord(seq_start);\n                s_end = get_draw_coord(seq_start + cig_len);\n\n                // Skip feature if it's not in tile.\n                if (!is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                    // Update offsets.\n                    base_offset = update_base_offset(base_offset, cig_op, cig_len);\n                    seq_offset = update_seq_offset(seq_offset, cig_op, cig_len);\n                    continue;\n                }\n\n                // Make sure that read is drawn even if it too small to be rendered officially; in this case,\n                // read is drawn at 1px.\n                // TODO: need to ensure that s_start, s_end are calculated the same for both slotting\n                // and drawing.\n                if (s_start === s_end) {\n                    s_end += 1;\n                }\n\n                // Draw read feature.\n                switch (cig_op) {\n                    case \"H\": // Hard clipping.\n                    case \"S\": // Soft clipping.\n                    case \"P\": // Padding.\n                        // Sequence not present and not related to alignment; do nothing.\n                        break;\n                    case \"M\": // \"Match\".\n                        // Because it's not known whether there is a match, ignore.\n                        base_offset += cig_len;\n                        break;\n                    case \"=\": // Match with reference.\n                    case \"X\": // Mismatch with reference.\n                        //\n                        // Draw sequence and/or variants.\n                        //\n\n                        // Get sequence to draw.\n                        var cur_seq = \"\";\n                        if (cig_op === \"X\") {\n                            // Get sequence from read_seq.\n                            cur_seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                        } else if (this.ref_seq) {\n                            // && cig_op === '='\n                            // Use reference sequence.\n                            cur_seq = this.ref_seq.slice(\n                                // If read starts after tile start, slice at read start.\n                                Math.max(0, seq_start - tile_low),\n                                // If read ends before tile end, slice at read end.\n                                Math.min(seq_start - tile_low + cig_len, tile_high - tile_low)\n                            );\n                        }\n\n                        // Draw sequence. Because cur_seq starts and read/tile start, go to there to start writing.\n                        var start_pos = Math.max(seq_start, tile_low);\n                        for (var c = 0; c < cur_seq.length; c++) {\n                            // Draw base if showing all (i.e. not showing differences) or there is a mismatch.\n                            if ((cur_seq && !this.prefs.show_differences) || cig_op === \"X\") {\n                                // Draw base.\n                                var c_start = Math.floor(Math.max(0, (start_pos + c - tile_low) * w_scale));\n                                ctx.fillStyle = this.base_color_fn(cur_seq[c]);\n                                if (pack_mode && w_scale > char_width_px) {\n                                    ctx.fillText(cur_seq[c], c_start, y_start + 9);\n                                } else if (w_scale > 0.05) {\n                                    // Require a minimum w_scale so that variants are only drawn when somewhat zoomed in.\n                                    ctx.fillRect(c_start - gap, rect_y, Math.max(1, Math.round(w_scale)), draw_height);\n                                }\n                            }\n                        }\n\n                        // Move forward in sequence only if sequence used to get mismatches.\n                        if (cig_op === \"X\") {\n                            seq_offset += cig_len;\n                        }\n                        base_offset += cig_len;\n\n                        break;\n                    case \"N\": // Skipped bases.\n                        ctx.fillStyle = CONNECTOR_COLOR;\n                        ctx.fillRect(s_start, rect_y + (draw_height - 1) / 2, s_end - s_start, 1);\n                        // No change in seq_offset because sequence not used when skipping.\n                        base_offset += cig_len;\n                        break;\n                    case \"D\": // Deletion.\n                        paint_utils.draw_deletion(s_start, rect_y, cig_len);\n                        base_offset += cig_len;\n                        break;\n                    case \"I\": // Insertion.\n                        // Check to see if sequence should be drawn at all by looking at the overlap between\n                        // the sequence region and the tile region.\n                        var insert_x_coord = s_start - gap;\n\n                        if (is_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                            var seq = read_seq.slice(seq_offset, seq_offset + cig_len);\n                            // Insertion point is between the sequence start and the previous base: (-gap) moves\n                            // back from sequence start to insertion point.\n                            if (this.prefs.show_insertions) {\n                                //\n                                // Show inserted sequence above, centered on insertion point.\n                                //\n\n                                // Draw sequence.\n                                // X center is offset + start - <half_sequence_length>\n                                var x_center = s_start - (s_end - s_start) / 2;\n                                if (\n                                    (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                    read_seq !== undefined &&\n                                    w_scale > char_width_px\n                                ) {\n                                    // Draw sequence container.\n                                    ctx.fillStyle = \"yellow\";\n                                    ctx.fillRect(x_center - gap, y_start - 9, s_end - s_start, 9);\n                                    draw_last[draw_last.length] = {\n                                        type: \"triangle\",\n                                        data: [insert_x_coord, y_start + 4, 5]\n                                    };\n                                    ctx.fillStyle = CONNECTOR_COLOR;\n                                    // Based on overlap b/t sequence and tile, get sequence to be drawn.\n                                    switch (compute_overlap([seq_start, seq_start + cig_len], tile_region)) {\n                                        case OVERLAP_START:\n                                            seq = seq.slice(tile_low - seq_start);\n                                            break;\n                                        case OVERLAP_END:\n                                            seq = seq.slice(0, seq_start - tile_high);\n                                            break;\n                                        case CONTAINED_BY:\n                                            // All of sequence drawn.\n                                            break;\n                                        case CONTAINS:\n                                            seq = seq.slice(tile_low - seq_start, seq_start - tile_high);\n                                            break;\n                                    }\n                                    // Draw sequence.\n                                    for (var c = 0, str_len = seq.length; c < str_len; c++) {\n                                        var c_start = Math.floor(Math.max(0, (seq_start + c - tile_low) * w_scale));\n                                        ctx.fillText(seq[c], c_start - (s_end - s_start) / 2, y_start);\n                                    }\n                                } else {\n                                    // Draw block.\n                                    ctx.fillStyle = \"yellow\";\n                                    // TODO: This is a pretty hack-ish way to fill rectangle based on mode.\n                                    ctx.fillRect(\n                                        x_center,\n                                        y_start + (this.mode !== \"Dense\" ? 2 : 5),\n                                        s_end - s_start,\n                                        mode !== \"Dense\" ? SQUISH_FEATURE_HEIGHT : DENSE_FEATURE_HEIGHT\n                                    );\n                                }\n                            } else {\n                                if (\n                                    (mode === \"Pack\" || this.mode === \"Auto\") &&\n                                    read_seq !== undefined &&\n                                    w_scale > char_width_px\n                                ) {\n                                    // Show insertions with a single number at the insertion point.\n                                    draw_last.push({\n                                        type: \"text\",\n                                        data: [seq.length, insert_x_coord, y_start + 9]\n                                    });\n                                } else {\n                                    // TODO: probably can merge this case with code above.\n                                }\n                            }\n                        }\n                        seq_offset += cig_len;\n                        // No change to base offset because insertions are drawn above sequence/read.\n                        break;\n                }\n            }\n\n            //\n            // Draw last items.\n            //\n            ctx.fillStyle = \"yellow\";\n            var item, type, data;\n            for (var i = 0; i < draw_last.length; i++) {\n                item = draw_last[i];\n                type = item.type;\n                data = item.data;\n                if (type === \"text\") {\n                    ctx.save();\n                    ctx.font = \"bold \" + ctx.font;\n                    ctx.fillText(data[0], data[1], data[2]);\n                    ctx.restore();\n                } else if (type === \"triangle\") {\n                    drawDownwardEquilateralTriangle(ctx, data[0], data[1], data[2]);\n                }\n            }\n        },\n\n        /**\n     * Draw a complete read pair\n     */\n        draw_element: function(ctx, mode, feature, slot, tile_low, tile_high, w_scale, y_scale, width) {\n            // All features need a start, end, and vertical center.\n            var feature_uid = feature[0],\n                feature_start = feature[1],\n                feature_end = feature[2],\n                feature_name = feature[3],\n                // -0.5 to put element between bases.\n                f_start = Math.floor(Math.max(-0.5 * w_scale, (feature_start - tile_low - 0.5) * w_scale)),\n                f_end = Math.ceil(Math.min(width, Math.max(0, (feature_end - tile_low - 0.5) * w_scale))),\n                y_start = (mode === \"Dense\" ? 0 : 0 + slot) * y_scale,\n                draw_height = mode === \"Pack\" ? PACK_FEATURE_HEIGHT : SQUISH_FEATURE_HEIGHT,\n                label_color = this.prefs.label_color;\n\n            // Draw read.\n            if (feature[5] instanceof Array) {\n                // Read is paired.\n                var connector = true;\n\n                // Draw left/forward read.\n                if (feature[4][1] >= tile_low && feature[4][0] <= tile_high && feature[4][2]) {\n                    this.draw_read(\n                        ctx,\n                        mode,\n                        w_scale,\n                        y_start,\n                        tile_low,\n                        tile_high,\n                        feature[4][0],\n                        feature[4][2],\n                        feature[4][3],\n                        feature[4][4]\n                    );\n                } else {\n                    connector = false;\n                }\n\n                // Draw right/reverse read.\n                if (feature[5][1] >= tile_low && feature[5][0] <= tile_high && feature[5][2]) {\n                    this.draw_read(\n                        ctx,\n                        mode,\n                        w_scale,\n                        y_start,\n                        tile_low,\n                        tile_high,\n                        feature[5][0],\n                        feature[5][2],\n                        feature[5][3],\n                        feature[5][4]\n                    );\n                } else {\n                    connector = false;\n                }\n\n                // Draw connector if both reads were drawn.\n                // TODO: currently, there is no way to connect reads drawn on different tiles; to connect reads on different tiles, data manager\n                // code is needed to join mate pairs from different regions. Alternatively, requesting multiple regions of data at once would\n                // make it possible to put together more easily.\n                // -0.5 to position connector correctly between reads.\n                var b1_end = Math.ceil(\n                        Math.min(width, Math.max(-0.5 * w_scale, (feature[4][1] - tile_low - 0.5) * w_scale))\n                    ),\n                    b2_start = Math.floor(Math.max(-0.5 * w_scale, (feature[5][0] - tile_low - 0.5) * w_scale));\n                if (connector && b2_start > b1_end) {\n                    ctx.fillStyle = CONNECTOR_COLOR;\n                    var line_height = y_start + 1 + (draw_height - 1) / 2;\n                    dashedLine(ctx, b1_end, line_height, b2_start, line_height);\n                }\n            } else {\n                // Read is single.\n                this.draw_read(\n                    ctx,\n                    mode,\n                    w_scale,\n                    y_start,\n                    tile_low,\n                    tile_high,\n                    feature_start,\n                    feature[4],\n                    feature[5],\n                    feature[6]\n                );\n            }\n            if (mode === \"Pack\" && feature_start >= tile_low && feature_name !== \".\") {\n                // Draw label.\n                ctx.fillStyle = this.prefs.label_color;\n                if (tile_low === 0 && f_start - ctx.measureText(feature_name).width < 0) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(feature_name, f_end + LABEL_SPACING, y_start + 9, this.max_label_length);\n                } else {\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(feature_name, f_start - LABEL_SPACING, y_start + 9, this.max_label_length);\n                }\n            }\n\n            // FIXME: provide actual coordinates for drawn read.\n            return [0, 0];\n        }\n    });\n\n    var ArcLinkedFeaturePainter = function(data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler) {\n        LinkedFeaturePainter.call(this, data, view_start, view_end, prefs, mode, alpha_scaler, height_scaler);\n        // Need to know the longest feature length for adding spacing\n        this.longest_feature_length = this.calculate_longest_feature_length();\n        this.draw_background_connector = false;\n        this.draw_individual_connectors = true;\n    };\n\n    _.extend(ArcLinkedFeaturePainter.prototype, FeaturePainter.prototype, LinkedFeaturePainter.prototype, {\n        calculate_longest_feature_length: function() {\n            var longest_feature_length = 0;\n            for (var i = 0, len = this.data.length; i < len; i++) {\n                var feature = this.data[i],\n                    feature_start = feature[1],\n                    feature_end = feature[2];\n                longest_feature_length = Math.max(longest_feature_length, feature_end - feature_start);\n            }\n            return longest_feature_length;\n        },\n\n        get_top_padding: function(width) {\n            var view_range = this.view_end - this.view_start,\n                w_scale = width / view_range;\n            return Math.min(128, Math.ceil(this.longest_feature_length / 2 * w_scale));\n        },\n\n        draw_connector: function(ctx, block1_start, block1_end, block2_start, block2_end, y_start) {\n            // Arc drawing -- from closest endpoints\n            var x_center = (block1_end + block2_start) / 2,\n                radius = block2_start - x_center;\n            // For full half circles\n            var angle1 = Math.PI,\n                angle2 = 0;\n            if (radius > 0) {\n                ctx.beginPath();\n                ctx.arc(x_center, y_start, block2_start - x_center, Math.PI, 0);\n                ctx.stroke();\n            }\n        }\n    });\n\n    // Color stuff from less.js\n\n    var Color = function(rgb, a) {\n        /**\n     * The end goal here, is to parse the arguments\n     * into an integer triplet, such as `128, 255, 0`\n     *\n     * This facilitates operations and conversions.\n     */\n        if (Array.isArray(rgb)) {\n            this.rgb = rgb;\n        } else if (rgb.length == 6) {\n            this.rgb = rgb.match(/.{2}/g).map(function(c) {\n                return parseInt(c, 16);\n            });\n        } else if (rgb.length == 7) {\n            this.rgb = rgb\n                .substring(1, 7)\n                .match(/.{2}/g)\n                .map(function(c) {\n                    return parseInt(c, 16);\n                });\n        } else {\n            this.rgb = rgb.split(\"\").map(function(c) {\n                return parseInt(c + c, 16);\n            });\n        }\n        this.alpha = typeof a === \"number\" ? a : 1;\n    };\n    Color.prototype = {\n        eval: function() {\n            return this;\n        },\n\n        //\n        // If we have some transparency, the only way to represent it\n        // is via `rgba`. Otherwise, we use the hex representation,\n        // which has better compatibility with older browsers.\n        // Values are capped between `0` and `255`, rounded and zero-padded.\n        //\n        toCSS: function() {\n            if (this.alpha < 1.0) {\n                return (\n                    \"rgba(\" +\n                    this.rgb\n                        .map(function(c) {\n                            return Math.round(c);\n                        })\n                        .concat(this.alpha)\n                        .join(\", \") +\n                    \")\"\n                );\n            } else {\n                return (\n                    \"#\" +\n                    this.rgb\n                        .map(function(i) {\n                            i = Math.round(i);\n                            i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                            return i.length === 1 ? \"0\" + i : i;\n                        })\n                        .join(\"\")\n                );\n            }\n        },\n\n        toHSL: function() {\n            var r = this.rgb[0] / 255,\n                g = this.rgb[1] / 255,\n                b = this.rgb[2] / 255,\n                a = this.alpha;\n\n            var max = Math.max(r, g, b),\n                min = Math.min(r, g, b);\n            var h,\n                s,\n                l = (max + min) / 2,\n                d = max - min;\n\n            if (max === min) {\n                h = s = 0;\n            } else {\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n                switch (max) {\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return { h: h * 360, s: s, l: l, a: a };\n        },\n\n        toARGB: function() {\n            var argb = [Math.round(this.alpha * 255)].concat(this.rgb);\n            return (\n                \"#\" +\n                argb\n                    .map(function(i) {\n                        i = Math.round(i);\n                        i = (i > 255 ? 255 : i < 0 ? 0 : i).toString(16);\n                        return i.length === 1 ? \"0\" + i : i;\n                    })\n                    .join(\"\")\n            );\n        },\n\n        mix: function(color2, weight) {\n            var color1 = this;\n\n            var p = weight; // .value / 100.0;\n            var w = p * 2 - 1;\n            var a = color1.toHSL().a - color2.toHSL().a;\n\n            var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            var w2 = 1 - w1;\n\n            var rgb = [\n                color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                color1.rgb[2] * w1 + color2.rgb[2] * w2\n            ];\n\n            var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n            return new Color(rgb, alpha);\n        }\n    };\n\n    // End colors from less.js\n\n    var LinearRamp = function(start_color, end_color, start_value, end_value) {\n        /**\n     * Simple linear gradient\n     */\n        this.start_color = new Color(start_color);\n        this.end_color = new Color(end_color);\n        this.start_value = start_value;\n        this.end_value = end_value;\n        this.value_range = end_value - start_value;\n    };\n\n    LinearRamp.prototype.map_value = function(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        value = (value - this.start_value) / this.value_range;\n        // HACK: just red for now\n        // return \"hsl(0,100%,\" + (value * 100) + \"%)\"\n        return this.start_color.mix(this.end_color, 1 - value).toCSS();\n    };\n\n    var SplitRamp = function(start_color, middle_color, end_color, start_value, end_value) {\n        /**\n     * Two gradients split away from 0\n     */\n        this.positive_ramp = new LinearRamp(middle_color, end_color, 0, end_value);\n        this.negative_ramp = new LinearRamp(middle_color, start_color, 0, -start_value);\n        this.start_value = start_value;\n        this.end_value = end_value;\n    };\n\n    SplitRamp.prototype.map_value = function(value) {\n        value = Math.max(value, this.start_value);\n        value = Math.min(value, this.end_value);\n        if (value >= 0) {\n            return this.positive_ramp.map_value(value);\n        } else {\n            return this.negative_ramp.map_value(-value);\n        }\n    };\n\n    var DiagonalHeatmapPainter = function(data, view_start, view_end, prefs, mode) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        var i, len;\n\n        if (this.prefs.min_value === undefined) {\n            var min_value = Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                min_value = Math.min(min_value, this.data[i][6]);\n            }\n            this.prefs.min_value = min_value;\n        }\n        if (this.prefs.max_value === undefined) {\n            var max_value = -Infinity;\n            for (i = 0, len = this.data.length; i < len; i++) {\n                max_value = Math.max(max_value, this.data[i][6]);\n            }\n            this.prefs.max_value = max_value;\n        }\n    };\n\n    DiagonalHeatmapPainter.prototype.default_prefs = {\n        min_value: undefined,\n        max_value: undefined,\n        mode: \"Heatmap\",\n        pos_color: \"#FF8C00\",\n        neg_color: \"#4169E1\"\n    };\n\n    DiagonalHeatmapPainter.prototype.draw = function(ctx, width, height, w_scale) {\n        var min_value = this.prefs.min_value,\n            max_value = this.prefs.max_value,\n            value_range = max_value - min_value,\n            height_px = height,\n            view_start = this.view_start,\n            mode = this.mode,\n            data = this.data,\n            invsqrt2 = 1 / Math.sqrt(2);\n\n        var ramp = new SplitRamp(this.prefs.neg_color, \"#FFFFFF\", this.prefs.pos_color, min_value, max_value);\n\n        var d, s1, e1, s2, e2, value;\n\n        var scale = function(p) {\n            return (p - view_start) * w_scale;\n        };\n\n        ctx.save();\n\n        // Draw into triangle, then rotate and scale\n        ctx.rotate(-45 * Math.PI / 180);\n        ctx.scale(invsqrt2, invsqrt2);\n\n        // Paint track.\n        for (var i = 0, len = data.length; i < len; i++) {\n            d = data[i];\n\n            s1 = scale(d[1]);\n            e1 = scale(d[2]);\n            s2 = scale(d[4]);\n            e2 = scale(d[5]);\n            value = d[6];\n\n            ctx.fillStyle = ramp.map_value(value);\n            ctx.fillRect(s1, s2, e1 - s1, e2 - s2);\n        }\n\n        ctx.restore();\n    };\n\n    /**\n * Utilities for painting reads.\n */\n    var ReadPainterUtils = function(ctx, row_height, px_per_base, mode) {\n        this.ctx = ctx;\n        this.row_height = row_height;\n        this.px_per_base = px_per_base;\n        this.draw_details = (mode === \"Pack\" || mode === \"Auto\") && px_per_base >= ctx.canvas.manager.char_width_px;\n        this.delete_details_thickness = 0.2;\n    };\n\n    _.extend(ReadPainterUtils.prototype, {\n        /**\n     * Draw deletion of base(s).\n     * @param draw_detail if true, drawing in detail and deletion is drawn more subtly\n     */\n        draw_deletion: function(x, y, len) {\n            this.ctx.fillStyle = \"black\";\n            var thickness = (this.draw_details ? this.delete_details_thickness : 1) * this.row_height;\n            y += 0.5 * (this.row_height - thickness);\n            this.ctx.fillRect(x, y, len * this.px_per_base, thickness);\n        }\n    });\n\n    /**\n * Paints variant data onto canvas.\n */\n    var VariantPainter = function(data, view_start, view_end, prefs, mode, base_color_fn) {\n        Painter.call(this, data, view_start, view_end, prefs, mode);\n        this.base_color_fn = base_color_fn;\n        this.divider_height = 1;\n    };\n\n    _.extend(VariantPainter.prototype, Painter.prototype, {\n        /**\n     * Height of a single row, depends on mode\n     */\n        get_row_height: function() {\n            var mode = this.mode,\n                height;\n            if (mode === \"Dense\") {\n                height = DENSE_TRACK_HEIGHT;\n            } else if (mode === \"Squish\") {\n                height = SQUISH_TRACK_HEIGHT;\n            } else {\n                // mode === \"Pack\"\n                height = PACK_TRACK_HEIGHT;\n            }\n            return height;\n        },\n\n        /**\n     * Returns required height to draw a particular number of samples in a given mode.\n     */\n        get_required_height: function(num_samples) {\n            // FIXME: for single-sample data, height should be summary_height when zoomed out and\n            // row_height when zoomed in.\n            var height = this.prefs.summary_height;\n\n            // If showing sample data, height is summary + divider + samples.\n            if (num_samples > 1 && this.prefs.show_sample_data) {\n                height += this.divider_height + num_samples * this.get_row_height();\n            }\n            return height;\n        },\n\n        /**\n     * Draw on the context using a rectangle of width x height with scale w_scale.\n     */\n        draw: function(ctx, width, height, w_scale) {\n            ctx.save();\n\n            var /**\n         * Returns dictionary of information about an indel; returns empty if there no indel. Assumes indel is left-aligned.\n         * Dict attributes:\n         *    -type: 'insertion' or 'deletion'\n         *    -start: where the deletion starts relative to reference start\n         *    -len: how long the deletion is\n         */\n            get_indel_info = function(ref, alt) {\n                var ref_len = ref.length,\n                    alt_len = alt.length,\n                    start = 0,\n                    len = 1,\n                    type = null;\n                if (alt === \"-\") {\n                    type = \"deletion\";\n                    len = ref.length;\n                } else if (ref.indexOf(alt) === 0 && ref_len > alt_len) {\n                    type = \"deletion\";\n                    len = ref_len - alt_len;\n                    start = alt_len;\n                } else if (alt.indexOf(ref) === 0 && ref_len < alt_len) {\n                    // Insertion.\n                    type = \"insertion\";\n                    len = alt_len - ref_len;\n                    start = alt_len;\n                }\n\n                return type !== null ? { type: type, start: start, len: len } : {};\n            };\n\n            // Draw.\n            var locus_data,\n                pos,\n                id,\n                ref,\n                alt,\n                qual,\n                filter,\n                sample_gts,\n                allele_counts,\n                variant,\n                draw_x_start,\n                draw_y_start,\n                genotype,\n                // Always draw variants at least 1 pixel wide.\n                base_px = Math.max(1, Math.floor(w_scale)),\n                // Determine number of samples.\n                num_samples = this.data.length ? this.data[0][7].split(\",\").length : 0,\n                row_height = this.mode === \"Squish\" ? SQUISH_TRACK_HEIGHT : PACK_TRACK_HEIGHT,\n                // If zoomed out, fill the whole row with feature to make it easier to read;\n                // when zoomed in, use feature height so that there are gaps in sample rows.\n                feature_height =\n                    w_scale < 0.1 ? row_height : this.mode === \"Squish\" ? SQUISH_FEATURE_HEIGHT : PACK_FEATURE_HEIGHT,\n                draw_summary = true,\n                paint_utils = new ReadPainterUtils(ctx, row_height, w_scale, this.mode),\n                j;\n\n            // If there's a single sample, update drawing variables.\n            if (num_samples === 1) {\n                row_height = feature_height =\n                    w_scale < ctx.canvas.manager.char_width_px ? this.prefs.summary_height : row_height;\n                paint_utils.row_height = row_height;\n                // No summary when there's a single sample.\n                draw_summary = false;\n            }\n\n            // Draw divider between summary and samples.\n            if (this.prefs.show_sample_data && draw_summary) {\n                ctx.fillStyle = \"#F3F3F3\";\n                ctx.globalAlpha = 1;\n                ctx.fillRect(0, this.prefs.summary_height - this.divider_height, width, this.divider_height);\n            }\n\n            // Draw variants.\n            ctx.textAlign = \"center\";\n            for (var i = 0; i < this.data.length; i++) {\n                // Get locus data.\n                locus_data = this.data[i];\n                pos = locus_data[1];\n                ref = locus_data[3];\n                alt = [locus_data[4].split(\",\")];\n                sample_gts = locus_data[7].split(\",\");\n                allele_counts = locus_data.slice(8);\n\n                // Process alterate values to derive information about each alt.\n                alt = _.map(_.flatten(alt), function(a) {\n                    var alt_info = {\n                            type: \"snp\",\n                            value: a,\n                            start: 0\n                        },\n                        indel_info = get_indel_info(ref, a);\n\n                    return _.extend(alt_info, indel_info);\n                });\n\n                // Only draw locus data if it's in viewing region.\n                if (pos < this.view_start || pos > this.view_end) {\n                    continue;\n                }\n\n                // Draw summary for alleles.\n                if (draw_summary) {\n                    ctx.fillStyle = \"#999999\";\n                    ctx.globalAlpha = 1;\n                    for (j = 0; j < alt.length; j++) {\n                        // Draw background for summary.\n                        draw_x_start = this.get_start_draw_pos(pos + alt[j].start, w_scale);\n                        ctx.fillRect(draw_x_start, 0, base_px, this.prefs.summary_height);\n                        draw_y_start = this.prefs.summary_height;\n                        // Draw allele fractions onto summary.\n                        for (j = 0; j < alt.length; j++) {\n                            ctx.fillStyle = alt[j].type === \"deletion\" ? \"black\" : this.base_color_fn(alt[j].value);\n                            var allele_frac = allele_counts / sample_gts.length;\n                            var draw_height = Math.ceil(this.prefs.summary_height * allele_frac);\n                            ctx.fillRect(draw_x_start, draw_y_start - draw_height, base_px, draw_height);\n                            draw_y_start -= draw_height;\n                        }\n                    }\n                }\n\n                // Done drawing if not showing samples data.\n                if (!this.prefs.show_sample_data) {\n                    continue;\n                }\n\n                // Draw sample genotype(s).\n                draw_y_start = draw_summary ? this.prefs.summary_height + this.divider_height : 0;\n                for (j = 0; j < sample_gts.length; j++, draw_y_start += row_height) {\n                    genotype = sample_gts[j] ? sample_gts[j].split(/\\/|\\|/) : [\"0\", \"0\"];\n\n                    // Get variant to draw and set drawing properties.\n                    variant = null;\n                    if (genotype[0] === genotype[1]) {\n                        if (genotype[0] === \".\") {\n                            // TODO: draw uncalled variant.\n                        } else if (genotype[0] !== \"0\") {\n                            // Homozygous for variant.\n                            variant = alt[parseInt(genotype[0], 10) - 1];\n                            ctx.globalAlpha = 1;\n                        }\n                        // else reference\n                    } else {\n                        // Heterozygous for variant.\n                        variant = genotype[0] !== \"0\" ? genotype[0] : genotype[1];\n                        variant = alt[parseInt(variant, 10) - 1];\n                        ctx.globalAlpha = 0.5;\n                    }\n\n                    // If there's a variant, draw it.\n                    if (variant) {\n                        draw_x_start = this.get_start_draw_pos(pos + variant.start, w_scale);\n                        if (variant.type === \"snp\") {\n                            var snp = variant.value;\n                            ctx.fillStyle = this.base_color_fn(snp);\n                            if (paint_utils.draw_details) {\n                                ctx.fillText(snp, this.get_draw_pos(pos, w_scale), draw_y_start + row_height);\n                            } else {\n                                ctx.fillRect(draw_x_start, draw_y_start + 1, base_px, feature_height);\n                            }\n                        } else if (variant.type === \"deletion\") {\n                            paint_utils.draw_deletion(draw_x_start, draw_y_start + 1, variant.len);\n                        } else {\n                            // TODO: handle insertions.\n                        }\n                    }\n                }\n            }\n\n            ctx.restore();\n        }\n    });\n\n    return {\n        Scaler: Scaler,\n        LinePainter: LinePainter,\n        LinkedFeaturePainter: LinkedFeaturePainter,\n        ReadPainter: ReadPainter,\n        ArcLinkedFeaturePainter: ArcLinkedFeaturePainter,\n        DiagonalHeatmapPainter: DiagonalHeatmapPainter,\n        VariantPainter: VariantPainter\n    };\n});\n"]}