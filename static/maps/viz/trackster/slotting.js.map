{"version":3,"sources":["viz/trackster/slotting.js"],"names":["define","_","SlottedInfo","slot","feature","this","FeatureSlotter","w_scale","mode","max_rows","measureText","slots","start_end_dct","include_label","extend","prototype","_get_draw_coords","Math","floor","draw_end","ceil","draw_start","undefined","f_name","text_len","width","text_align","_find_slot","draw_coords","slot_num","has_overlap","k","k_len","length","s_e","slot_features","features","highest_slot","undone","i","len","feature_uid","slotted_info","slotted_coords","old_draw_coords","new_draw_coords","dc","max","push"],"mappings":"aAAAA,QAAQ,mBAAoB,SAASC,GACjC,IASIC,EAAc,SAASC,EAAMC,GAC7BC,KAAKF,KAAOA,EADZD,KAAAA,QAAcE,GAYdE,EAAiB,SAASC,EAASC,EAAMC,EAAUC,GACnDL,KAAKM,SADLL,KAAAA,iBACAD,KAAKM,QAALJ,EACAF,KAAKO,KAAAA,EACLP,KAAKE,cAAL,SAAeA,EACfF,KAAKG,SAALC,EACAJ,KAAKQ,YAALH,GA0KJ,OAjKAI,EAnCab,EAAEa,QAmCRR,EAAeS,WAIlBC,iBAAkB,SAASZ,GAA3BY,IAAAA,EAAkBC,KAAAC,MAAAd,EAAA,GAASA,KAAAA,SACvBe,EAAAF,KAAAG,KAAAhB,EAAA,GAAAC,KAAAE,SACIc,EAAAA,EAAaJ,GAKjB,QAAAK,IAAAC,GAAAlB,KAAAQ,cAAA,CAGI,IAAAW,EAAAnB,KAAAK,YAAAa,GAAAE,MAAA,EACAJ,EAAAG,GAAA,GACIA,GAAWA,EACEA,SAEbE,GAAAA,EACG,SA4BX,OAAQL,EAAYF,IAOxBQ,WAAY,SAASC,GAEjB,IACIT,IAFJE,EAAAO,EAAA,GACIP,EAAAA,EAAaO,GACbT,EAAWS,EAAAA,GADfvB,KAAAI,SAAAoB,IAAA,CAEA,IAAKC,GAAL,EACQA,EAAAA,KAAAA,cAAJD,GAAA,QACWP,IAAPnB,EAEA,IAAA,IAAA4B,EAAA,EAAAC,EAAA7B,EAAA8B,OAAAF,EAAAC,EAAAD,IAAA,CACA,IAAKG,EAAA/B,EAAW6B,GACZ,GAAIE,EAAWH,EAAf,IAAAV,EAAAa,EAAA,GAAA,CAEIJ,GAAA,EACAA,OAIX,IAAAA,EACG,OAACA,EAGR,OAAA,GAOLK,cAAe,SAASC,GASpB,IAAA,IANIC,EACAjC,EAJR+B,EAAe9B,KAAAO,cACPA,KACA0B,EADJ,EAQAC,EAAA,EAAAC,EAAAJ,EAAAH,OAAAM,EAAAC,EAAAD,IAAA,CAEInC,GADJA,EAAKgC,EAAiBA,IAClB,GACAK,IAAAA,EAAcrC,KAAdO,MAAA8B,GAGA,GAAAC,EAAA,CAGI,GAAAtC,EAAA,GAAAsC,EAAAtC,QAAA,IAAAsC,EAAAtC,QAAA,GAAAA,EAAA,GAII,IAEIuC,IAHJC,EAAAvC,KAAAW,iBAAA0B,EAAAtC,SACIwC,EAAkBvC,KAAKW,iBAAiB0B,GACxCG,EAAAA,KAAkBjC,cAAKI,EAD3Bb,MAEIwC,EAAAA,EAAAA,EAAAA,EAAsB/B,OAAc8B,IAAAA,CACxC,IAAKI,EAAQH,EAAOA,GACZG,EAAAA,KAAKH,EAAT,IAAAG,EAAA,KAAAF,EAAA,KAEID,EAAAZ,GAAAc,GAIXR,EAAApB,KAAA8B,IAAAV,EAAAhC,KAAAM,MAAA8B,GAAAtC,WAhBLmC,EAkBOU,KAAAT,GAOX,IAAA,IAAAA,EAAA,EAAAC,EAAAF,EAAAL,OAAAM,EAAAC,EAAAD,IAAA,CAEInC,GADJA,EAAKgC,EAAiBE,EAAOL,KACNK,GACnBG,IAAAA,EAAcrC,KAAAY,iBAAdZ,GAGAyB,EAAAxB,KAAAsB,WAAAC,GAGAC,GAAA,SAEIP,IAAAV,EAAAiB,KACIjB,EAAciB,OAEjBjB,EAAAiB,GAAAmB,KAAApB,GACDhB,KAAAA,MAAAA,GAAwBoC,IAAKpB,EAA7BC,EAAAzB,GACAiC,EAAWI,KAAAA,IAAXJ,EAA8BnC,IAiBtC,OAAOmC,EAAe,MAI9B/B,eAAOA","file":"../../../scripts/viz/trackster/slotting.js","sourcesContent":["define([\"libs/underscore\"], function(_) {\n    var extend = _.extend;\n\n    // HACK: LABEL_SPACING is currently duplicated between here and painters\n    var LABEL_SPACING = 2,\n        PACK_SPACING = 5;\n\n    /**\n * Hold slotting information for a feature.\n */\n    var SlottedInfo = function(slot, feature) {\n        this.slot = slot;\n        this.feature = feature;\n    };\n\n    /**\n * FeatureSlotter determines slots in which to draw features for vertical\n * packing.\n *\n * This implementation is incremental, any feature assigned a slot will be\n * retained for slotting future features.\n */\n    var FeatureSlotter = function(w_scale, mode, max_rows, measureText) {\n        this.slots = {};\n        this.start_end_dct = {};\n        this.w_scale = w_scale;\n        this.mode = mode;\n        this.include_label = mode === \"Pack\";\n        this.max_rows = max_rows;\n        this.measureText = measureText;\n    };\n\n    /**\n * Slot a set of features, `this.slots` will be updated with slots by id, and\n * the largest slot required for the passed set of features is returned\n */\n    extend(FeatureSlotter.prototype, {\n        /**\n     * Get drawing coordinate for a feature.\n     */\n        _get_draw_coords: function(feature) {\n            // Get initial draw coordinates using w_scale.\n            var draw_start = Math.floor(feature[1] * this.w_scale),\n                draw_end = Math.ceil(feature[2] * this.w_scale),\n                f_name = feature[3],\n                text_align;\n\n            // Update start, end drawing locations to include feature name.\n            // Try to put the name on the left, if not, put on right.\n            if (f_name !== undefined && this.include_label) {\n                // Add gap for label spacing and extra pack space padding\n                // TODO: Fix constants\n                var text_len = this.measureText(f_name).width + (LABEL_SPACING + PACK_SPACING);\n                if (draw_start - text_len >= 0) {\n                    draw_start -= text_len;\n                    text_align = \"left\";\n                } else {\n                    draw_end += text_len;\n                    text_align = \"right\";\n                }\n            }\n\n            /*\n        if (slot_num < 0) {\n            \n            TODO: this is not yet working --\n            console.log(feature_uid, \"looking for slot with text on the right\");\n            // Slot not found. If text was on left, try on right and see\n            // if slot can be found.\n            // TODO: are there any checks we need to do to ensure that text\n            // will fit on tile?\n            if (text_align === \"left\") {\n                draw_start -= text_len;\n                draw_end -= text_len;\n                text_align = \"right\";\n                slot_num = find_slot(draw_start, draw_end);\n            }\n            if (slot_num >= 0) {\n                console.log(feature_uid, \"found slot with text on the right\");\n            }\n\n        }\n        */\n\n            return [draw_start, draw_end];\n        },\n\n        /**\n     * Find the first slot such that current feature doesn't overlap any other features in that slot.\n     * Returns -1 if no slot was found.\n     */\n        _find_slot: function(draw_coords) {\n            // TODO: Use a data structure for faster searching of available slots.\n            var draw_start = draw_coords[0],\n                draw_end = draw_coords[1];\n            for (var slot_num = 0; slot_num <= this.max_rows; slot_num++) {\n                var has_overlap = false,\n                    slot = this.start_end_dct[slot_num];\n                if (slot !== undefined) {\n                    // Iterate through features already in slot to see if current feature will fit.\n                    for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                        var s_e = slot[k];\n                        if (draw_end > s_e[0] && draw_start < s_e[1]) {\n                            // There is overlap\n                            has_overlap = true;\n                            break;\n                        }\n                    }\n                }\n                if (!has_overlap) {\n                    return slot_num;\n                }\n            }\n            return -1;\n        },\n\n        /**\n     * Slot features.\n     */\n        slot_features: function(features) {\n            var start_end_dct = this.start_end_dct,\n                undone = [],\n                highest_slot = 0,\n                feature,\n                feature_uid;\n\n            // Loop through features to (a) find those that are not yet slotted and (b) update\n            // those that are slotted if new information is availabe. For (a), features already\n            // slotted (based on slotting from other tiles) will retain their current slot.\n            for (var i = 0, len = features.length; i < len; i++) {\n                feature = features[i];\n                feature_uid = feature[0];\n                var slotted_info = this.slots[feature_uid];\n\n                // Separate and handle slotted vs. unslotted features.\n                if (slotted_info) {\n                    // Feature is slotted; if feature now has larger start/end coordinates,\n                    // update drawing coordinates.\n                    if (feature[1] < slotted_info.feature[1] || slotted_info.feature[2] < feature[2]) {\n                        // Feature has changed (e.g. a single read now has its pair), so recalculate its\n                        // drawing coordinates.\n                        var old_draw_coords = this._get_draw_coords(slotted_info.feature),\n                            new_draw_coords = this._get_draw_coords(feature),\n                            slotted_coords = this.start_end_dct[slotted_info.slot];\n                        for (var k = 0; k < slotted_coords.length; k++) {\n                            var dc = slotted_coords[k];\n                            if (dc[0] === old_draw_coords[0] && dc[1] === old_draw_coords[1]) {\n                                // Replace old drawing coordinates with new ones.\n                                slotted_coords[k] = new_draw_coords;\n                            }\n                        }\n                    }\n                    highest_slot = Math.max(highest_slot, this.slots[feature_uid].slot);\n                } else {\n                    undone.push(i);\n                }\n            }\n\n            // Slot unslotted features.\n\n            // Do slotting.\n            for (var i = 0, len = undone.length; i < len; i++) {\n                feature = features[undone[i]];\n                feature_uid = feature[0];\n                var draw_coords = this._get_draw_coords(feature);\n\n                // Find slot.\n                var slot_num = this._find_slot(draw_coords);\n\n                // Do slotting.\n                if (slot_num >= 0) {\n                    // Add current feature to slot.\n                    if (start_end_dct[slot_num] === undefined) {\n                        start_end_dct[slot_num] = [];\n                    }\n                    start_end_dct[slot_num].push(draw_coords);\n                    this.slots[feature_uid] = new SlottedInfo(slot_num, feature);\n                    highest_slot = Math.max(highest_slot, slot_num);\n                }\n            }\n\n            // Debugging: view slots data.\n            /*\n        for (var i = 0; i < MAX_FEATURE_DEPTH; i++) {\n            var slot = start_end_dct[i];\n            if (slot !== undefined) {\n                console.log(i, \"*************\");\n                for (var k = 0, k_len = slot.length; k < k_len; k++) {\n                    console.log(\"\\t\", slot[k][0], slot[k][1]);\n                }\n            }\n        }\n        */\n            return highest_slot + 1;\n        }\n    });\n\n    return {\n        FeatureSlotter: FeatureSlotter\n    };\n});\n"]}